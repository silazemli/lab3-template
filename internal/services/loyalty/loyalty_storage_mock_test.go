// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package loyalty

//go:generate minimock -i github.com/silazemli/lab2-template/internal/services/loyalty.loyaltyStorage -o loyalty_storage_mock_test.go -n LoyaltyStorageMock -p loyalty

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoyaltyStorageMock implements loyaltyStorage
type LoyaltyStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDecrementCounter          func(username string) (err error)
	funcDecrementCounterOrigin    string
	inspectFuncDecrementCounter   func(username string)
	afterDecrementCounterCounter  uint64
	beforeDecrementCounterCounter uint64
	DecrementCounterMock          mLoyaltyStorageMockDecrementCounter

	funcGetUser          func(username string) (l1 Loyalty, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(username string)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mLoyaltyStorageMockGetUser

	funcIncrementCounter          func(username string) (err error)
	funcIncrementCounterOrigin    string
	inspectFuncIncrementCounter   func(username string)
	afterIncrementCounterCounter  uint64
	beforeIncrementCounterCounter uint64
	IncrementCounterMock          mLoyaltyStorageMockIncrementCounter
}

// NewLoyaltyStorageMock returns a mock for loyaltyStorage
func NewLoyaltyStorageMock(t minimock.Tester) *LoyaltyStorageMock {
	m := &LoyaltyStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DecrementCounterMock = mLoyaltyStorageMockDecrementCounter{mock: m}
	m.DecrementCounterMock.callArgs = []*LoyaltyStorageMockDecrementCounterParams{}

	m.GetUserMock = mLoyaltyStorageMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*LoyaltyStorageMockGetUserParams{}

	m.IncrementCounterMock = mLoyaltyStorageMockIncrementCounter{mock: m}
	m.IncrementCounterMock.callArgs = []*LoyaltyStorageMockIncrementCounterParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoyaltyStorageMockDecrementCounter struct {
	optional           bool
	mock               *LoyaltyStorageMock
	defaultExpectation *LoyaltyStorageMockDecrementCounterExpectation
	expectations       []*LoyaltyStorageMockDecrementCounterExpectation

	callArgs []*LoyaltyStorageMockDecrementCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoyaltyStorageMockDecrementCounterExpectation specifies expectation struct of the loyaltyStorage.DecrementCounter
type LoyaltyStorageMockDecrementCounterExpectation struct {
	mock               *LoyaltyStorageMock
	params             *LoyaltyStorageMockDecrementCounterParams
	paramPtrs          *LoyaltyStorageMockDecrementCounterParamPtrs
	expectationOrigins LoyaltyStorageMockDecrementCounterExpectationOrigins
	results            *LoyaltyStorageMockDecrementCounterResults
	returnOrigin       string
	Counter            uint64
}

// LoyaltyStorageMockDecrementCounterParams contains parameters of the loyaltyStorage.DecrementCounter
type LoyaltyStorageMockDecrementCounterParams struct {
	username string
}

// LoyaltyStorageMockDecrementCounterParamPtrs contains pointers to parameters of the loyaltyStorage.DecrementCounter
type LoyaltyStorageMockDecrementCounterParamPtrs struct {
	username *string
}

// LoyaltyStorageMockDecrementCounterResults contains results of the loyaltyStorage.DecrementCounter
type LoyaltyStorageMockDecrementCounterResults struct {
	err error
}

// LoyaltyStorageMockDecrementCounterOrigins contains origins of expectations of the loyaltyStorage.DecrementCounter
type LoyaltyStorageMockDecrementCounterExpectationOrigins struct {
	origin         string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Optional() *mLoyaltyStorageMockDecrementCounter {
	mmDecrementCounter.optional = true
	return mmDecrementCounter
}

// Expect sets up expected params for loyaltyStorage.DecrementCounter
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Expect(username string) *mLoyaltyStorageMockDecrementCounter {
	if mmDecrementCounter.mock.funcDecrementCounter != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by Set")
	}

	if mmDecrementCounter.defaultExpectation == nil {
		mmDecrementCounter.defaultExpectation = &LoyaltyStorageMockDecrementCounterExpectation{}
	}

	if mmDecrementCounter.defaultExpectation.paramPtrs != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by ExpectParams functions")
	}

	mmDecrementCounter.defaultExpectation.params = &LoyaltyStorageMockDecrementCounterParams{username}
	mmDecrementCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDecrementCounter.expectations {
		if minimock.Equal(e.params, mmDecrementCounter.defaultExpectation.params) {
			mmDecrementCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecrementCounter.defaultExpectation.params)
		}
	}

	return mmDecrementCounter
}

// ExpectUsernameParam1 sets up expected param username for loyaltyStorage.DecrementCounter
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) ExpectUsernameParam1(username string) *mLoyaltyStorageMockDecrementCounter {
	if mmDecrementCounter.mock.funcDecrementCounter != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by Set")
	}

	if mmDecrementCounter.defaultExpectation == nil {
		mmDecrementCounter.defaultExpectation = &LoyaltyStorageMockDecrementCounterExpectation{}
	}

	if mmDecrementCounter.defaultExpectation.params != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by Expect")
	}

	if mmDecrementCounter.defaultExpectation.paramPtrs == nil {
		mmDecrementCounter.defaultExpectation.paramPtrs = &LoyaltyStorageMockDecrementCounterParamPtrs{}
	}
	mmDecrementCounter.defaultExpectation.paramPtrs.username = &username
	mmDecrementCounter.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmDecrementCounter
}

// Inspect accepts an inspector function that has same arguments as the loyaltyStorage.DecrementCounter
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Inspect(f func(username string)) *mLoyaltyStorageMockDecrementCounter {
	if mmDecrementCounter.mock.inspectFuncDecrementCounter != nil {
		mmDecrementCounter.mock.t.Fatalf("Inspect function is already set for LoyaltyStorageMock.DecrementCounter")
	}

	mmDecrementCounter.mock.inspectFuncDecrementCounter = f

	return mmDecrementCounter
}

// Return sets up results that will be returned by loyaltyStorage.DecrementCounter
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Return(err error) *LoyaltyStorageMock {
	if mmDecrementCounter.mock.funcDecrementCounter != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by Set")
	}

	if mmDecrementCounter.defaultExpectation == nil {
		mmDecrementCounter.defaultExpectation = &LoyaltyStorageMockDecrementCounterExpectation{mock: mmDecrementCounter.mock}
	}
	mmDecrementCounter.defaultExpectation.results = &LoyaltyStorageMockDecrementCounterResults{err}
	mmDecrementCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDecrementCounter.mock
}

// Set uses given function f to mock the loyaltyStorage.DecrementCounter method
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Set(f func(username string) (err error)) *LoyaltyStorageMock {
	if mmDecrementCounter.defaultExpectation != nil {
		mmDecrementCounter.mock.t.Fatalf("Default expectation is already set for the loyaltyStorage.DecrementCounter method")
	}

	if len(mmDecrementCounter.expectations) > 0 {
		mmDecrementCounter.mock.t.Fatalf("Some expectations are already set for the loyaltyStorage.DecrementCounter method")
	}

	mmDecrementCounter.mock.funcDecrementCounter = f
	mmDecrementCounter.mock.funcDecrementCounterOrigin = minimock.CallerInfo(1)
	return mmDecrementCounter.mock
}

// When sets expectation for the loyaltyStorage.DecrementCounter which will trigger the result defined by the following
// Then helper
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) When(username string) *LoyaltyStorageMockDecrementCounterExpectation {
	if mmDecrementCounter.mock.funcDecrementCounter != nil {
		mmDecrementCounter.mock.t.Fatalf("LoyaltyStorageMock.DecrementCounter mock is already set by Set")
	}

	expectation := &LoyaltyStorageMockDecrementCounterExpectation{
		mock:               mmDecrementCounter.mock,
		params:             &LoyaltyStorageMockDecrementCounterParams{username},
		expectationOrigins: LoyaltyStorageMockDecrementCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDecrementCounter.expectations = append(mmDecrementCounter.expectations, expectation)
	return expectation
}

// Then sets up loyaltyStorage.DecrementCounter return parameters for the expectation previously defined by the When method
func (e *LoyaltyStorageMockDecrementCounterExpectation) Then(err error) *LoyaltyStorageMock {
	e.results = &LoyaltyStorageMockDecrementCounterResults{err}
	return e.mock
}

// Times sets number of times loyaltyStorage.DecrementCounter should be invoked
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Times(n uint64) *mLoyaltyStorageMockDecrementCounter {
	if n == 0 {
		mmDecrementCounter.mock.t.Fatalf("Times of LoyaltyStorageMock.DecrementCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDecrementCounter.expectedInvocations, n)
	mmDecrementCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDecrementCounter
}

func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) invocationsDone() bool {
	if len(mmDecrementCounter.expectations) == 0 && mmDecrementCounter.defaultExpectation == nil && mmDecrementCounter.mock.funcDecrementCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDecrementCounter.mock.afterDecrementCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDecrementCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DecrementCounter implements loyaltyStorage
func (mmDecrementCounter *LoyaltyStorageMock) DecrementCounter(username string) (err error) {
	mm_atomic.AddUint64(&mmDecrementCounter.beforeDecrementCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmDecrementCounter.afterDecrementCounterCounter, 1)

	mmDecrementCounter.t.Helper()

	if mmDecrementCounter.inspectFuncDecrementCounter != nil {
		mmDecrementCounter.inspectFuncDecrementCounter(username)
	}

	mm_params := LoyaltyStorageMockDecrementCounterParams{username}

	// Record call args
	mmDecrementCounter.DecrementCounterMock.mutex.Lock()
	mmDecrementCounter.DecrementCounterMock.callArgs = append(mmDecrementCounter.DecrementCounterMock.callArgs, &mm_params)
	mmDecrementCounter.DecrementCounterMock.mutex.Unlock()

	for _, e := range mmDecrementCounter.DecrementCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecrementCounter.DecrementCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecrementCounter.DecrementCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmDecrementCounter.DecrementCounterMock.defaultExpectation.params
		mm_want_ptrs := mmDecrementCounter.DecrementCounterMock.defaultExpectation.paramPtrs

		mm_got := LoyaltyStorageMockDecrementCounterParams{username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmDecrementCounter.t.Errorf("LoyaltyStorageMock.DecrementCounter got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDecrementCounter.DecrementCounterMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecrementCounter.t.Errorf("LoyaltyStorageMock.DecrementCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDecrementCounter.DecrementCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecrementCounter.DecrementCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmDecrementCounter.t.Fatal("No results are set for the LoyaltyStorageMock.DecrementCounter")
		}
		return (*mm_results).err
	}
	if mmDecrementCounter.funcDecrementCounter != nil {
		return mmDecrementCounter.funcDecrementCounter(username)
	}
	mmDecrementCounter.t.Fatalf("Unexpected call to LoyaltyStorageMock.DecrementCounter. %v", username)
	return
}

// DecrementCounterAfterCounter returns a count of finished LoyaltyStorageMock.DecrementCounter invocations
func (mmDecrementCounter *LoyaltyStorageMock) DecrementCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrementCounter.afterDecrementCounterCounter)
}

// DecrementCounterBeforeCounter returns a count of LoyaltyStorageMock.DecrementCounter invocations
func (mmDecrementCounter *LoyaltyStorageMock) DecrementCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrementCounter.beforeDecrementCounterCounter)
}

// Calls returns a list of arguments used in each call to LoyaltyStorageMock.DecrementCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecrementCounter *mLoyaltyStorageMockDecrementCounter) Calls() []*LoyaltyStorageMockDecrementCounterParams {
	mmDecrementCounter.mutex.RLock()

	argCopy := make([]*LoyaltyStorageMockDecrementCounterParams, len(mmDecrementCounter.callArgs))
	copy(argCopy, mmDecrementCounter.callArgs)

	mmDecrementCounter.mutex.RUnlock()

	return argCopy
}

// MinimockDecrementCounterDone returns true if the count of the DecrementCounter invocations corresponds
// the number of defined expectations
func (m *LoyaltyStorageMock) MinimockDecrementCounterDone() bool {
	if m.DecrementCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DecrementCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DecrementCounterMock.invocationsDone()
}

// MinimockDecrementCounterInspect logs each unmet expectation
func (m *LoyaltyStorageMock) MinimockDecrementCounterInspect() {
	for _, e := range m.DecrementCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoyaltyStorageMock.DecrementCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDecrementCounterCounter := mm_atomic.LoadUint64(&m.afterDecrementCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DecrementCounterMock.defaultExpectation != nil && afterDecrementCounterCounter < 1 {
		if m.DecrementCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoyaltyStorageMock.DecrementCounter at\n%s", m.DecrementCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoyaltyStorageMock.DecrementCounter at\n%s with params: %#v", m.DecrementCounterMock.defaultExpectation.expectationOrigins.origin, *m.DecrementCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecrementCounter != nil && afterDecrementCounterCounter < 1 {
		m.t.Errorf("Expected call to LoyaltyStorageMock.DecrementCounter at\n%s", m.funcDecrementCounterOrigin)
	}

	if !m.DecrementCounterMock.invocationsDone() && afterDecrementCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to LoyaltyStorageMock.DecrementCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DecrementCounterMock.expectedInvocations), m.DecrementCounterMock.expectedInvocationsOrigin, afterDecrementCounterCounter)
	}
}

type mLoyaltyStorageMockGetUser struct {
	optional           bool
	mock               *LoyaltyStorageMock
	defaultExpectation *LoyaltyStorageMockGetUserExpectation
	expectations       []*LoyaltyStorageMockGetUserExpectation

	callArgs []*LoyaltyStorageMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoyaltyStorageMockGetUserExpectation specifies expectation struct of the loyaltyStorage.GetUser
type LoyaltyStorageMockGetUserExpectation struct {
	mock               *LoyaltyStorageMock
	params             *LoyaltyStorageMockGetUserParams
	paramPtrs          *LoyaltyStorageMockGetUserParamPtrs
	expectationOrigins LoyaltyStorageMockGetUserExpectationOrigins
	results            *LoyaltyStorageMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// LoyaltyStorageMockGetUserParams contains parameters of the loyaltyStorage.GetUser
type LoyaltyStorageMockGetUserParams struct {
	username string
}

// LoyaltyStorageMockGetUserParamPtrs contains pointers to parameters of the loyaltyStorage.GetUser
type LoyaltyStorageMockGetUserParamPtrs struct {
	username *string
}

// LoyaltyStorageMockGetUserResults contains results of the loyaltyStorage.GetUser
type LoyaltyStorageMockGetUserResults struct {
	l1  Loyalty
	err error
}

// LoyaltyStorageMockGetUserOrigins contains origins of expectations of the loyaltyStorage.GetUser
type LoyaltyStorageMockGetUserExpectationOrigins struct {
	origin         string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mLoyaltyStorageMockGetUser) Optional() *mLoyaltyStorageMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for loyaltyStorage.GetUser
func (mmGetUser *mLoyaltyStorageMockGetUser) Expect(username string) *mLoyaltyStorageMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &LoyaltyStorageMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &LoyaltyStorageMockGetUserParams{username}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectUsernameParam1 sets up expected param username for loyaltyStorage.GetUser
func (mmGetUser *mLoyaltyStorageMockGetUser) ExpectUsernameParam1(username string) *mLoyaltyStorageMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &LoyaltyStorageMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &LoyaltyStorageMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.username = &username
	mmGetUser.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the loyaltyStorage.GetUser
func (mmGetUser *mLoyaltyStorageMockGetUser) Inspect(f func(username string)) *mLoyaltyStorageMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for LoyaltyStorageMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by loyaltyStorage.GetUser
func (mmGetUser *mLoyaltyStorageMockGetUser) Return(l1 Loyalty, err error) *LoyaltyStorageMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &LoyaltyStorageMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &LoyaltyStorageMockGetUserResults{l1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the loyaltyStorage.GetUser method
func (mmGetUser *mLoyaltyStorageMockGetUser) Set(f func(username string) (l1 Loyalty, err error)) *LoyaltyStorageMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the loyaltyStorage.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the loyaltyStorage.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the loyaltyStorage.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mLoyaltyStorageMockGetUser) When(username string) *LoyaltyStorageMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("LoyaltyStorageMock.GetUser mock is already set by Set")
	}

	expectation := &LoyaltyStorageMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &LoyaltyStorageMockGetUserParams{username},
		expectationOrigins: LoyaltyStorageMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up loyaltyStorage.GetUser return parameters for the expectation previously defined by the When method
func (e *LoyaltyStorageMockGetUserExpectation) Then(l1 Loyalty, err error) *LoyaltyStorageMock {
	e.results = &LoyaltyStorageMockGetUserResults{l1, err}
	return e.mock
}

// Times sets number of times loyaltyStorage.GetUser should be invoked
func (mmGetUser *mLoyaltyStorageMockGetUser) Times(n uint64) *mLoyaltyStorageMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of LoyaltyStorageMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mLoyaltyStorageMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements loyaltyStorage
func (mmGetUser *LoyaltyStorageMock) GetUser(username string) (l1 Loyalty, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(username)
	}

	mm_params := LoyaltyStorageMockGetUserParams{username}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := LoyaltyStorageMockGetUserParams{username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUser.t.Errorf("LoyaltyStorageMock.GetUser got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("LoyaltyStorageMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the LoyaltyStorageMock.GetUser")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(username)
	}
	mmGetUser.t.Fatalf("Unexpected call to LoyaltyStorageMock.GetUser. %v", username)
	return
}

// GetUserAfterCounter returns a count of finished LoyaltyStorageMock.GetUser invocations
func (mmGetUser *LoyaltyStorageMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of LoyaltyStorageMock.GetUser invocations
func (mmGetUser *LoyaltyStorageMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to LoyaltyStorageMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mLoyaltyStorageMockGetUser) Calls() []*LoyaltyStorageMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*LoyaltyStorageMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *LoyaltyStorageMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *LoyaltyStorageMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoyaltyStorageMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoyaltyStorageMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoyaltyStorageMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to LoyaltyStorageMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to LoyaltyStorageMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mLoyaltyStorageMockIncrementCounter struct {
	optional           bool
	mock               *LoyaltyStorageMock
	defaultExpectation *LoyaltyStorageMockIncrementCounterExpectation
	expectations       []*LoyaltyStorageMockIncrementCounterExpectation

	callArgs []*LoyaltyStorageMockIncrementCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoyaltyStorageMockIncrementCounterExpectation specifies expectation struct of the loyaltyStorage.IncrementCounter
type LoyaltyStorageMockIncrementCounterExpectation struct {
	mock               *LoyaltyStorageMock
	params             *LoyaltyStorageMockIncrementCounterParams
	paramPtrs          *LoyaltyStorageMockIncrementCounterParamPtrs
	expectationOrigins LoyaltyStorageMockIncrementCounterExpectationOrigins
	results            *LoyaltyStorageMockIncrementCounterResults
	returnOrigin       string
	Counter            uint64
}

// LoyaltyStorageMockIncrementCounterParams contains parameters of the loyaltyStorage.IncrementCounter
type LoyaltyStorageMockIncrementCounterParams struct {
	username string
}

// LoyaltyStorageMockIncrementCounterParamPtrs contains pointers to parameters of the loyaltyStorage.IncrementCounter
type LoyaltyStorageMockIncrementCounterParamPtrs struct {
	username *string
}

// LoyaltyStorageMockIncrementCounterResults contains results of the loyaltyStorage.IncrementCounter
type LoyaltyStorageMockIncrementCounterResults struct {
	err error
}

// LoyaltyStorageMockIncrementCounterOrigins contains origins of expectations of the loyaltyStorage.IncrementCounter
type LoyaltyStorageMockIncrementCounterExpectationOrigins struct {
	origin         string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Optional() *mLoyaltyStorageMockIncrementCounter {
	mmIncrementCounter.optional = true
	return mmIncrementCounter
}

// Expect sets up expected params for loyaltyStorage.IncrementCounter
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Expect(username string) *mLoyaltyStorageMockIncrementCounter {
	if mmIncrementCounter.mock.funcIncrementCounter != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by Set")
	}

	if mmIncrementCounter.defaultExpectation == nil {
		mmIncrementCounter.defaultExpectation = &LoyaltyStorageMockIncrementCounterExpectation{}
	}

	if mmIncrementCounter.defaultExpectation.paramPtrs != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by ExpectParams functions")
	}

	mmIncrementCounter.defaultExpectation.params = &LoyaltyStorageMockIncrementCounterParams{username}
	mmIncrementCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIncrementCounter.expectations {
		if minimock.Equal(e.params, mmIncrementCounter.defaultExpectation.params) {
			mmIncrementCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncrementCounter.defaultExpectation.params)
		}
	}

	return mmIncrementCounter
}

// ExpectUsernameParam1 sets up expected param username for loyaltyStorage.IncrementCounter
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) ExpectUsernameParam1(username string) *mLoyaltyStorageMockIncrementCounter {
	if mmIncrementCounter.mock.funcIncrementCounter != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by Set")
	}

	if mmIncrementCounter.defaultExpectation == nil {
		mmIncrementCounter.defaultExpectation = &LoyaltyStorageMockIncrementCounterExpectation{}
	}

	if mmIncrementCounter.defaultExpectation.params != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by Expect")
	}

	if mmIncrementCounter.defaultExpectation.paramPtrs == nil {
		mmIncrementCounter.defaultExpectation.paramPtrs = &LoyaltyStorageMockIncrementCounterParamPtrs{}
	}
	mmIncrementCounter.defaultExpectation.paramPtrs.username = &username
	mmIncrementCounter.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmIncrementCounter
}

// Inspect accepts an inspector function that has same arguments as the loyaltyStorage.IncrementCounter
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Inspect(f func(username string)) *mLoyaltyStorageMockIncrementCounter {
	if mmIncrementCounter.mock.inspectFuncIncrementCounter != nil {
		mmIncrementCounter.mock.t.Fatalf("Inspect function is already set for LoyaltyStorageMock.IncrementCounter")
	}

	mmIncrementCounter.mock.inspectFuncIncrementCounter = f

	return mmIncrementCounter
}

// Return sets up results that will be returned by loyaltyStorage.IncrementCounter
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Return(err error) *LoyaltyStorageMock {
	if mmIncrementCounter.mock.funcIncrementCounter != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by Set")
	}

	if mmIncrementCounter.defaultExpectation == nil {
		mmIncrementCounter.defaultExpectation = &LoyaltyStorageMockIncrementCounterExpectation{mock: mmIncrementCounter.mock}
	}
	mmIncrementCounter.defaultExpectation.results = &LoyaltyStorageMockIncrementCounterResults{err}
	mmIncrementCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncrementCounter.mock
}

// Set uses given function f to mock the loyaltyStorage.IncrementCounter method
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Set(f func(username string) (err error)) *LoyaltyStorageMock {
	if mmIncrementCounter.defaultExpectation != nil {
		mmIncrementCounter.mock.t.Fatalf("Default expectation is already set for the loyaltyStorage.IncrementCounter method")
	}

	if len(mmIncrementCounter.expectations) > 0 {
		mmIncrementCounter.mock.t.Fatalf("Some expectations are already set for the loyaltyStorage.IncrementCounter method")
	}

	mmIncrementCounter.mock.funcIncrementCounter = f
	mmIncrementCounter.mock.funcIncrementCounterOrigin = minimock.CallerInfo(1)
	return mmIncrementCounter.mock
}

// When sets expectation for the loyaltyStorage.IncrementCounter which will trigger the result defined by the following
// Then helper
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) When(username string) *LoyaltyStorageMockIncrementCounterExpectation {
	if mmIncrementCounter.mock.funcIncrementCounter != nil {
		mmIncrementCounter.mock.t.Fatalf("LoyaltyStorageMock.IncrementCounter mock is already set by Set")
	}

	expectation := &LoyaltyStorageMockIncrementCounterExpectation{
		mock:               mmIncrementCounter.mock,
		params:             &LoyaltyStorageMockIncrementCounterParams{username},
		expectationOrigins: LoyaltyStorageMockIncrementCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIncrementCounter.expectations = append(mmIncrementCounter.expectations, expectation)
	return expectation
}

// Then sets up loyaltyStorage.IncrementCounter return parameters for the expectation previously defined by the When method
func (e *LoyaltyStorageMockIncrementCounterExpectation) Then(err error) *LoyaltyStorageMock {
	e.results = &LoyaltyStorageMockIncrementCounterResults{err}
	return e.mock
}

// Times sets number of times loyaltyStorage.IncrementCounter should be invoked
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Times(n uint64) *mLoyaltyStorageMockIncrementCounter {
	if n == 0 {
		mmIncrementCounter.mock.t.Fatalf("Times of LoyaltyStorageMock.IncrementCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncrementCounter.expectedInvocations, n)
	mmIncrementCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncrementCounter
}

func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) invocationsDone() bool {
	if len(mmIncrementCounter.expectations) == 0 && mmIncrementCounter.defaultExpectation == nil && mmIncrementCounter.mock.funcIncrementCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncrementCounter.mock.afterIncrementCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncrementCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncrementCounter implements loyaltyStorage
func (mmIncrementCounter *LoyaltyStorageMock) IncrementCounter(username string) (err error) {
	mm_atomic.AddUint64(&mmIncrementCounter.beforeIncrementCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmIncrementCounter.afterIncrementCounterCounter, 1)

	mmIncrementCounter.t.Helper()

	if mmIncrementCounter.inspectFuncIncrementCounter != nil {
		mmIncrementCounter.inspectFuncIncrementCounter(username)
	}

	mm_params := LoyaltyStorageMockIncrementCounterParams{username}

	// Record call args
	mmIncrementCounter.IncrementCounterMock.mutex.Lock()
	mmIncrementCounter.IncrementCounterMock.callArgs = append(mmIncrementCounter.IncrementCounterMock.callArgs, &mm_params)
	mmIncrementCounter.IncrementCounterMock.mutex.Unlock()

	for _, e := range mmIncrementCounter.IncrementCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncrementCounter.IncrementCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncrementCounter.IncrementCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmIncrementCounter.IncrementCounterMock.defaultExpectation.params
		mm_want_ptrs := mmIncrementCounter.IncrementCounterMock.defaultExpectation.paramPtrs

		mm_got := LoyaltyStorageMockIncrementCounterParams{username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmIncrementCounter.t.Errorf("LoyaltyStorageMock.IncrementCounter got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncrementCounter.IncrementCounterMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncrementCounter.t.Errorf("LoyaltyStorageMock.IncrementCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIncrementCounter.IncrementCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncrementCounter.IncrementCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmIncrementCounter.t.Fatal("No results are set for the LoyaltyStorageMock.IncrementCounter")
		}
		return (*mm_results).err
	}
	if mmIncrementCounter.funcIncrementCounter != nil {
		return mmIncrementCounter.funcIncrementCounter(username)
	}
	mmIncrementCounter.t.Fatalf("Unexpected call to LoyaltyStorageMock.IncrementCounter. %v", username)
	return
}

// IncrementCounterAfterCounter returns a count of finished LoyaltyStorageMock.IncrementCounter invocations
func (mmIncrementCounter *LoyaltyStorageMock) IncrementCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncrementCounter.afterIncrementCounterCounter)
}

// IncrementCounterBeforeCounter returns a count of LoyaltyStorageMock.IncrementCounter invocations
func (mmIncrementCounter *LoyaltyStorageMock) IncrementCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncrementCounter.beforeIncrementCounterCounter)
}

// Calls returns a list of arguments used in each call to LoyaltyStorageMock.IncrementCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncrementCounter *mLoyaltyStorageMockIncrementCounter) Calls() []*LoyaltyStorageMockIncrementCounterParams {
	mmIncrementCounter.mutex.RLock()

	argCopy := make([]*LoyaltyStorageMockIncrementCounterParams, len(mmIncrementCounter.callArgs))
	copy(argCopy, mmIncrementCounter.callArgs)

	mmIncrementCounter.mutex.RUnlock()

	return argCopy
}

// MinimockIncrementCounterDone returns true if the count of the IncrementCounter invocations corresponds
// the number of defined expectations
func (m *LoyaltyStorageMock) MinimockIncrementCounterDone() bool {
	if m.IncrementCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncrementCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncrementCounterMock.invocationsDone()
}

// MinimockIncrementCounterInspect logs each unmet expectation
func (m *LoyaltyStorageMock) MinimockIncrementCounterInspect() {
	for _, e := range m.IncrementCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoyaltyStorageMock.IncrementCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIncrementCounterCounter := mm_atomic.LoadUint64(&m.afterIncrementCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncrementCounterMock.defaultExpectation != nil && afterIncrementCounterCounter < 1 {
		if m.IncrementCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoyaltyStorageMock.IncrementCounter at\n%s", m.IncrementCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoyaltyStorageMock.IncrementCounter at\n%s with params: %#v", m.IncrementCounterMock.defaultExpectation.expectationOrigins.origin, *m.IncrementCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncrementCounter != nil && afterIncrementCounterCounter < 1 {
		m.t.Errorf("Expected call to LoyaltyStorageMock.IncrementCounter at\n%s", m.funcIncrementCounterOrigin)
	}

	if !m.IncrementCounterMock.invocationsDone() && afterIncrementCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to LoyaltyStorageMock.IncrementCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncrementCounterMock.expectedInvocations), m.IncrementCounterMock.expectedInvocationsOrigin, afterIncrementCounterCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoyaltyStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDecrementCounterInspect()

			m.MinimockGetUserInspect()

			m.MinimockIncrementCounterInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoyaltyStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoyaltyStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDecrementCounterDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockIncrementCounterDone()
}
