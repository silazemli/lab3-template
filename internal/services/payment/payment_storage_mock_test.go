// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package payment

//go:generate minimock -i github.com/silazemli/lab2-template/internal/services/payment.paymentStorage -o payment_storage_mock_test.go -n PaymentStorageMock -p payment

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PaymentStorageMock implements paymentStorage
type PaymentStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelPayment          func(paymentUID string) (err error)
	funcCancelPaymentOrigin    string
	inspectFuncCancelPayment   func(paymentUID string)
	afterCancelPaymentCounter  uint64
	beforeCancelPaymentCounter uint64
	CancelPaymentMock          mPaymentStorageMockCancelPayment

	funcGetPayment          func(paymentUID string) (p1 Payment, err error)
	funcGetPaymentOrigin    string
	inspectFuncGetPayment   func(paymentUID string)
	afterGetPaymentCounter  uint64
	beforeGetPaymentCounter uint64
	GetPaymentMock          mPaymentStorageMockGetPayment

	funcPostPayment          func(thePayment Payment) (err error)
	funcPostPaymentOrigin    string
	inspectFuncPostPayment   func(thePayment Payment)
	afterPostPaymentCounter  uint64
	beforePostPaymentCounter uint64
	PostPaymentMock          mPaymentStorageMockPostPayment
}

// NewPaymentStorageMock returns a mock for paymentStorage
func NewPaymentStorageMock(t minimock.Tester) *PaymentStorageMock {
	m := &PaymentStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelPaymentMock = mPaymentStorageMockCancelPayment{mock: m}
	m.CancelPaymentMock.callArgs = []*PaymentStorageMockCancelPaymentParams{}

	m.GetPaymentMock = mPaymentStorageMockGetPayment{mock: m}
	m.GetPaymentMock.callArgs = []*PaymentStorageMockGetPaymentParams{}

	m.PostPaymentMock = mPaymentStorageMockPostPayment{mock: m}
	m.PostPaymentMock.callArgs = []*PaymentStorageMockPostPaymentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPaymentStorageMockCancelPayment struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockCancelPaymentExpectation
	expectations       []*PaymentStorageMockCancelPaymentExpectation

	callArgs []*PaymentStorageMockCancelPaymentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockCancelPaymentExpectation specifies expectation struct of the paymentStorage.CancelPayment
type PaymentStorageMockCancelPaymentExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockCancelPaymentParams
	paramPtrs          *PaymentStorageMockCancelPaymentParamPtrs
	expectationOrigins PaymentStorageMockCancelPaymentExpectationOrigins
	results            *PaymentStorageMockCancelPaymentResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockCancelPaymentParams contains parameters of the paymentStorage.CancelPayment
type PaymentStorageMockCancelPaymentParams struct {
	paymentUID string
}

// PaymentStorageMockCancelPaymentParamPtrs contains pointers to parameters of the paymentStorage.CancelPayment
type PaymentStorageMockCancelPaymentParamPtrs struct {
	paymentUID *string
}

// PaymentStorageMockCancelPaymentResults contains results of the paymentStorage.CancelPayment
type PaymentStorageMockCancelPaymentResults struct {
	err error
}

// PaymentStorageMockCancelPaymentOrigins contains origins of expectations of the paymentStorage.CancelPayment
type PaymentStorageMockCancelPaymentExpectationOrigins struct {
	origin           string
	originPaymentUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Optional() *mPaymentStorageMockCancelPayment {
	mmCancelPayment.optional = true
	return mmCancelPayment
}

// Expect sets up expected params for paymentStorage.CancelPayment
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Expect(paymentUID string) *mPaymentStorageMockCancelPayment {
	if mmCancelPayment.mock.funcCancelPayment != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by Set")
	}

	if mmCancelPayment.defaultExpectation == nil {
		mmCancelPayment.defaultExpectation = &PaymentStorageMockCancelPaymentExpectation{}
	}

	if mmCancelPayment.defaultExpectation.paramPtrs != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by ExpectParams functions")
	}

	mmCancelPayment.defaultExpectation.params = &PaymentStorageMockCancelPaymentParams{paymentUID}
	mmCancelPayment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelPayment.expectations {
		if minimock.Equal(e.params, mmCancelPayment.defaultExpectation.params) {
			mmCancelPayment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelPayment.defaultExpectation.params)
		}
	}

	return mmCancelPayment
}

// ExpectPaymentUIDParam1 sets up expected param paymentUID for paymentStorage.CancelPayment
func (mmCancelPayment *mPaymentStorageMockCancelPayment) ExpectPaymentUIDParam1(paymentUID string) *mPaymentStorageMockCancelPayment {
	if mmCancelPayment.mock.funcCancelPayment != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by Set")
	}

	if mmCancelPayment.defaultExpectation == nil {
		mmCancelPayment.defaultExpectation = &PaymentStorageMockCancelPaymentExpectation{}
	}

	if mmCancelPayment.defaultExpectation.params != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by Expect")
	}

	if mmCancelPayment.defaultExpectation.paramPtrs == nil {
		mmCancelPayment.defaultExpectation.paramPtrs = &PaymentStorageMockCancelPaymentParamPtrs{}
	}
	mmCancelPayment.defaultExpectation.paramPtrs.paymentUID = &paymentUID
	mmCancelPayment.defaultExpectation.expectationOrigins.originPaymentUID = minimock.CallerInfo(1)

	return mmCancelPayment
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.CancelPayment
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Inspect(f func(paymentUID string)) *mPaymentStorageMockCancelPayment {
	if mmCancelPayment.mock.inspectFuncCancelPayment != nil {
		mmCancelPayment.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.CancelPayment")
	}

	mmCancelPayment.mock.inspectFuncCancelPayment = f

	return mmCancelPayment
}

// Return sets up results that will be returned by paymentStorage.CancelPayment
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Return(err error) *PaymentStorageMock {
	if mmCancelPayment.mock.funcCancelPayment != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by Set")
	}

	if mmCancelPayment.defaultExpectation == nil {
		mmCancelPayment.defaultExpectation = &PaymentStorageMockCancelPaymentExpectation{mock: mmCancelPayment.mock}
	}
	mmCancelPayment.defaultExpectation.results = &PaymentStorageMockCancelPaymentResults{err}
	mmCancelPayment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelPayment.mock
}

// Set uses given function f to mock the paymentStorage.CancelPayment method
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Set(f func(paymentUID string) (err error)) *PaymentStorageMock {
	if mmCancelPayment.defaultExpectation != nil {
		mmCancelPayment.mock.t.Fatalf("Default expectation is already set for the paymentStorage.CancelPayment method")
	}

	if len(mmCancelPayment.expectations) > 0 {
		mmCancelPayment.mock.t.Fatalf("Some expectations are already set for the paymentStorage.CancelPayment method")
	}

	mmCancelPayment.mock.funcCancelPayment = f
	mmCancelPayment.mock.funcCancelPaymentOrigin = minimock.CallerInfo(1)
	return mmCancelPayment.mock
}

// When sets expectation for the paymentStorage.CancelPayment which will trigger the result defined by the following
// Then helper
func (mmCancelPayment *mPaymentStorageMockCancelPayment) When(paymentUID string) *PaymentStorageMockCancelPaymentExpectation {
	if mmCancelPayment.mock.funcCancelPayment != nil {
		mmCancelPayment.mock.t.Fatalf("PaymentStorageMock.CancelPayment mock is already set by Set")
	}

	expectation := &PaymentStorageMockCancelPaymentExpectation{
		mock:               mmCancelPayment.mock,
		params:             &PaymentStorageMockCancelPaymentParams{paymentUID},
		expectationOrigins: PaymentStorageMockCancelPaymentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelPayment.expectations = append(mmCancelPayment.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.CancelPayment return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockCancelPaymentExpectation) Then(err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockCancelPaymentResults{err}
	return e.mock
}

// Times sets number of times paymentStorage.CancelPayment should be invoked
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Times(n uint64) *mPaymentStorageMockCancelPayment {
	if n == 0 {
		mmCancelPayment.mock.t.Fatalf("Times of PaymentStorageMock.CancelPayment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelPayment.expectedInvocations, n)
	mmCancelPayment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelPayment
}

func (mmCancelPayment *mPaymentStorageMockCancelPayment) invocationsDone() bool {
	if len(mmCancelPayment.expectations) == 0 && mmCancelPayment.defaultExpectation == nil && mmCancelPayment.mock.funcCancelPayment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelPayment.mock.afterCancelPaymentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelPayment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelPayment implements paymentStorage
func (mmCancelPayment *PaymentStorageMock) CancelPayment(paymentUID string) (err error) {
	mm_atomic.AddUint64(&mmCancelPayment.beforeCancelPaymentCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelPayment.afterCancelPaymentCounter, 1)

	mmCancelPayment.t.Helper()

	if mmCancelPayment.inspectFuncCancelPayment != nil {
		mmCancelPayment.inspectFuncCancelPayment(paymentUID)
	}

	mm_params := PaymentStorageMockCancelPaymentParams{paymentUID}

	// Record call args
	mmCancelPayment.CancelPaymentMock.mutex.Lock()
	mmCancelPayment.CancelPaymentMock.callArgs = append(mmCancelPayment.CancelPaymentMock.callArgs, &mm_params)
	mmCancelPayment.CancelPaymentMock.mutex.Unlock()

	for _, e := range mmCancelPayment.CancelPaymentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelPayment.CancelPaymentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelPayment.CancelPaymentMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelPayment.CancelPaymentMock.defaultExpectation.params
		mm_want_ptrs := mmCancelPayment.CancelPaymentMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockCancelPaymentParams{paymentUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.paymentUID != nil && !minimock.Equal(*mm_want_ptrs.paymentUID, mm_got.paymentUID) {
				mmCancelPayment.t.Errorf("PaymentStorageMock.CancelPayment got unexpected parameter paymentUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelPayment.CancelPaymentMock.defaultExpectation.expectationOrigins.originPaymentUID, *mm_want_ptrs.paymentUID, mm_got.paymentUID, minimock.Diff(*mm_want_ptrs.paymentUID, mm_got.paymentUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelPayment.t.Errorf("PaymentStorageMock.CancelPayment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelPayment.CancelPaymentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelPayment.CancelPaymentMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelPayment.t.Fatal("No results are set for the PaymentStorageMock.CancelPayment")
		}
		return (*mm_results).err
	}
	if mmCancelPayment.funcCancelPayment != nil {
		return mmCancelPayment.funcCancelPayment(paymentUID)
	}
	mmCancelPayment.t.Fatalf("Unexpected call to PaymentStorageMock.CancelPayment. %v", paymentUID)
	return
}

// CancelPaymentAfterCounter returns a count of finished PaymentStorageMock.CancelPayment invocations
func (mmCancelPayment *PaymentStorageMock) CancelPaymentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelPayment.afterCancelPaymentCounter)
}

// CancelPaymentBeforeCounter returns a count of PaymentStorageMock.CancelPayment invocations
func (mmCancelPayment *PaymentStorageMock) CancelPaymentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelPayment.beforeCancelPaymentCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.CancelPayment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelPayment *mPaymentStorageMockCancelPayment) Calls() []*PaymentStorageMockCancelPaymentParams {
	mmCancelPayment.mutex.RLock()

	argCopy := make([]*PaymentStorageMockCancelPaymentParams, len(mmCancelPayment.callArgs))
	copy(argCopy, mmCancelPayment.callArgs)

	mmCancelPayment.mutex.RUnlock()

	return argCopy
}

// MinimockCancelPaymentDone returns true if the count of the CancelPayment invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockCancelPaymentDone() bool {
	if m.CancelPaymentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelPaymentMock.invocationsDone()
}

// MinimockCancelPaymentInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockCancelPaymentInspect() {
	for _, e := range m.CancelPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.CancelPayment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelPaymentCounter := mm_atomic.LoadUint64(&m.afterCancelPaymentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelPaymentMock.defaultExpectation != nil && afterCancelPaymentCounter < 1 {
		if m.CancelPaymentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.CancelPayment at\n%s", m.CancelPaymentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.CancelPayment at\n%s with params: %#v", m.CancelPaymentMock.defaultExpectation.expectationOrigins.origin, *m.CancelPaymentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelPayment != nil && afterCancelPaymentCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.CancelPayment at\n%s", m.funcCancelPaymentOrigin)
	}

	if !m.CancelPaymentMock.invocationsDone() && afterCancelPaymentCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.CancelPayment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelPaymentMock.expectedInvocations), m.CancelPaymentMock.expectedInvocationsOrigin, afterCancelPaymentCounter)
	}
}

type mPaymentStorageMockGetPayment struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockGetPaymentExpectation
	expectations       []*PaymentStorageMockGetPaymentExpectation

	callArgs []*PaymentStorageMockGetPaymentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockGetPaymentExpectation specifies expectation struct of the paymentStorage.GetPayment
type PaymentStorageMockGetPaymentExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockGetPaymentParams
	paramPtrs          *PaymentStorageMockGetPaymentParamPtrs
	expectationOrigins PaymentStorageMockGetPaymentExpectationOrigins
	results            *PaymentStorageMockGetPaymentResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockGetPaymentParams contains parameters of the paymentStorage.GetPayment
type PaymentStorageMockGetPaymentParams struct {
	paymentUID string
}

// PaymentStorageMockGetPaymentParamPtrs contains pointers to parameters of the paymentStorage.GetPayment
type PaymentStorageMockGetPaymentParamPtrs struct {
	paymentUID *string
}

// PaymentStorageMockGetPaymentResults contains results of the paymentStorage.GetPayment
type PaymentStorageMockGetPaymentResults struct {
	p1  Payment
	err error
}

// PaymentStorageMockGetPaymentOrigins contains origins of expectations of the paymentStorage.GetPayment
type PaymentStorageMockGetPaymentExpectationOrigins struct {
	origin           string
	originPaymentUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPayment *mPaymentStorageMockGetPayment) Optional() *mPaymentStorageMockGetPayment {
	mmGetPayment.optional = true
	return mmGetPayment
}

// Expect sets up expected params for paymentStorage.GetPayment
func (mmGetPayment *mPaymentStorageMockGetPayment) Expect(paymentUID string) *mPaymentStorageMockGetPayment {
	if mmGetPayment.mock.funcGetPayment != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by Set")
	}

	if mmGetPayment.defaultExpectation == nil {
		mmGetPayment.defaultExpectation = &PaymentStorageMockGetPaymentExpectation{}
	}

	if mmGetPayment.defaultExpectation.paramPtrs != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by ExpectParams functions")
	}

	mmGetPayment.defaultExpectation.params = &PaymentStorageMockGetPaymentParams{paymentUID}
	mmGetPayment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPayment.expectations {
		if minimock.Equal(e.params, mmGetPayment.defaultExpectation.params) {
			mmGetPayment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPayment.defaultExpectation.params)
		}
	}

	return mmGetPayment
}

// ExpectPaymentUIDParam1 sets up expected param paymentUID for paymentStorage.GetPayment
func (mmGetPayment *mPaymentStorageMockGetPayment) ExpectPaymentUIDParam1(paymentUID string) *mPaymentStorageMockGetPayment {
	if mmGetPayment.mock.funcGetPayment != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by Set")
	}

	if mmGetPayment.defaultExpectation == nil {
		mmGetPayment.defaultExpectation = &PaymentStorageMockGetPaymentExpectation{}
	}

	if mmGetPayment.defaultExpectation.params != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by Expect")
	}

	if mmGetPayment.defaultExpectation.paramPtrs == nil {
		mmGetPayment.defaultExpectation.paramPtrs = &PaymentStorageMockGetPaymentParamPtrs{}
	}
	mmGetPayment.defaultExpectation.paramPtrs.paymentUID = &paymentUID
	mmGetPayment.defaultExpectation.expectationOrigins.originPaymentUID = minimock.CallerInfo(1)

	return mmGetPayment
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.GetPayment
func (mmGetPayment *mPaymentStorageMockGetPayment) Inspect(f func(paymentUID string)) *mPaymentStorageMockGetPayment {
	if mmGetPayment.mock.inspectFuncGetPayment != nil {
		mmGetPayment.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.GetPayment")
	}

	mmGetPayment.mock.inspectFuncGetPayment = f

	return mmGetPayment
}

// Return sets up results that will be returned by paymentStorage.GetPayment
func (mmGetPayment *mPaymentStorageMockGetPayment) Return(p1 Payment, err error) *PaymentStorageMock {
	if mmGetPayment.mock.funcGetPayment != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by Set")
	}

	if mmGetPayment.defaultExpectation == nil {
		mmGetPayment.defaultExpectation = &PaymentStorageMockGetPaymentExpectation{mock: mmGetPayment.mock}
	}
	mmGetPayment.defaultExpectation.results = &PaymentStorageMockGetPaymentResults{p1, err}
	mmGetPayment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPayment.mock
}

// Set uses given function f to mock the paymentStorage.GetPayment method
func (mmGetPayment *mPaymentStorageMockGetPayment) Set(f func(paymentUID string) (p1 Payment, err error)) *PaymentStorageMock {
	if mmGetPayment.defaultExpectation != nil {
		mmGetPayment.mock.t.Fatalf("Default expectation is already set for the paymentStorage.GetPayment method")
	}

	if len(mmGetPayment.expectations) > 0 {
		mmGetPayment.mock.t.Fatalf("Some expectations are already set for the paymentStorage.GetPayment method")
	}

	mmGetPayment.mock.funcGetPayment = f
	mmGetPayment.mock.funcGetPaymentOrigin = minimock.CallerInfo(1)
	return mmGetPayment.mock
}

// When sets expectation for the paymentStorage.GetPayment which will trigger the result defined by the following
// Then helper
func (mmGetPayment *mPaymentStorageMockGetPayment) When(paymentUID string) *PaymentStorageMockGetPaymentExpectation {
	if mmGetPayment.mock.funcGetPayment != nil {
		mmGetPayment.mock.t.Fatalf("PaymentStorageMock.GetPayment mock is already set by Set")
	}

	expectation := &PaymentStorageMockGetPaymentExpectation{
		mock:               mmGetPayment.mock,
		params:             &PaymentStorageMockGetPaymentParams{paymentUID},
		expectationOrigins: PaymentStorageMockGetPaymentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPayment.expectations = append(mmGetPayment.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.GetPayment return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockGetPaymentExpectation) Then(p1 Payment, err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockGetPaymentResults{p1, err}
	return e.mock
}

// Times sets number of times paymentStorage.GetPayment should be invoked
func (mmGetPayment *mPaymentStorageMockGetPayment) Times(n uint64) *mPaymentStorageMockGetPayment {
	if n == 0 {
		mmGetPayment.mock.t.Fatalf("Times of PaymentStorageMock.GetPayment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPayment.expectedInvocations, n)
	mmGetPayment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPayment
}

func (mmGetPayment *mPaymentStorageMockGetPayment) invocationsDone() bool {
	if len(mmGetPayment.expectations) == 0 && mmGetPayment.defaultExpectation == nil && mmGetPayment.mock.funcGetPayment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPayment.mock.afterGetPaymentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPayment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPayment implements paymentStorage
func (mmGetPayment *PaymentStorageMock) GetPayment(paymentUID string) (p1 Payment, err error) {
	mm_atomic.AddUint64(&mmGetPayment.beforeGetPaymentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPayment.afterGetPaymentCounter, 1)

	mmGetPayment.t.Helper()

	if mmGetPayment.inspectFuncGetPayment != nil {
		mmGetPayment.inspectFuncGetPayment(paymentUID)
	}

	mm_params := PaymentStorageMockGetPaymentParams{paymentUID}

	// Record call args
	mmGetPayment.GetPaymentMock.mutex.Lock()
	mmGetPayment.GetPaymentMock.callArgs = append(mmGetPayment.GetPaymentMock.callArgs, &mm_params)
	mmGetPayment.GetPaymentMock.mutex.Unlock()

	for _, e := range mmGetPayment.GetPaymentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPayment.GetPaymentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPayment.GetPaymentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPayment.GetPaymentMock.defaultExpectation.params
		mm_want_ptrs := mmGetPayment.GetPaymentMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockGetPaymentParams{paymentUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.paymentUID != nil && !minimock.Equal(*mm_want_ptrs.paymentUID, mm_got.paymentUID) {
				mmGetPayment.t.Errorf("PaymentStorageMock.GetPayment got unexpected parameter paymentUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPayment.GetPaymentMock.defaultExpectation.expectationOrigins.originPaymentUID, *mm_want_ptrs.paymentUID, mm_got.paymentUID, minimock.Diff(*mm_want_ptrs.paymentUID, mm_got.paymentUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPayment.t.Errorf("PaymentStorageMock.GetPayment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPayment.GetPaymentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPayment.GetPaymentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPayment.t.Fatal("No results are set for the PaymentStorageMock.GetPayment")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPayment.funcGetPayment != nil {
		return mmGetPayment.funcGetPayment(paymentUID)
	}
	mmGetPayment.t.Fatalf("Unexpected call to PaymentStorageMock.GetPayment. %v", paymentUID)
	return
}

// GetPaymentAfterCounter returns a count of finished PaymentStorageMock.GetPayment invocations
func (mmGetPayment *PaymentStorageMock) GetPaymentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPayment.afterGetPaymentCounter)
}

// GetPaymentBeforeCounter returns a count of PaymentStorageMock.GetPayment invocations
func (mmGetPayment *PaymentStorageMock) GetPaymentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPayment.beforeGetPaymentCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.GetPayment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPayment *mPaymentStorageMockGetPayment) Calls() []*PaymentStorageMockGetPaymentParams {
	mmGetPayment.mutex.RLock()

	argCopy := make([]*PaymentStorageMockGetPaymentParams, len(mmGetPayment.callArgs))
	copy(argCopy, mmGetPayment.callArgs)

	mmGetPayment.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaymentDone returns true if the count of the GetPayment invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockGetPaymentDone() bool {
	if m.GetPaymentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaymentMock.invocationsDone()
}

// MinimockGetPaymentInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockGetPaymentInspect() {
	for _, e := range m.GetPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPayment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaymentCounter := mm_atomic.LoadUint64(&m.afterGetPaymentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaymentMock.defaultExpectation != nil && afterGetPaymentCounter < 1 {
		if m.GetPaymentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPayment at\n%s", m.GetPaymentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPayment at\n%s with params: %#v", m.GetPaymentMock.defaultExpectation.expectationOrigins.origin, *m.GetPaymentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPayment != nil && afterGetPaymentCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.GetPayment at\n%s", m.funcGetPaymentOrigin)
	}

	if !m.GetPaymentMock.invocationsDone() && afterGetPaymentCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.GetPayment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaymentMock.expectedInvocations), m.GetPaymentMock.expectedInvocationsOrigin, afterGetPaymentCounter)
	}
}

type mPaymentStorageMockPostPayment struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockPostPaymentExpectation
	expectations       []*PaymentStorageMockPostPaymentExpectation

	callArgs []*PaymentStorageMockPostPaymentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockPostPaymentExpectation specifies expectation struct of the paymentStorage.PostPayment
type PaymentStorageMockPostPaymentExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockPostPaymentParams
	paramPtrs          *PaymentStorageMockPostPaymentParamPtrs
	expectationOrigins PaymentStorageMockPostPaymentExpectationOrigins
	results            *PaymentStorageMockPostPaymentResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockPostPaymentParams contains parameters of the paymentStorage.PostPayment
type PaymentStorageMockPostPaymentParams struct {
	thePayment Payment
}

// PaymentStorageMockPostPaymentParamPtrs contains pointers to parameters of the paymentStorage.PostPayment
type PaymentStorageMockPostPaymentParamPtrs struct {
	thePayment *Payment
}

// PaymentStorageMockPostPaymentResults contains results of the paymentStorage.PostPayment
type PaymentStorageMockPostPaymentResults struct {
	err error
}

// PaymentStorageMockPostPaymentOrigins contains origins of expectations of the paymentStorage.PostPayment
type PaymentStorageMockPostPaymentExpectationOrigins struct {
	origin           string
	originThePayment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPostPayment *mPaymentStorageMockPostPayment) Optional() *mPaymentStorageMockPostPayment {
	mmPostPayment.optional = true
	return mmPostPayment
}

// Expect sets up expected params for paymentStorage.PostPayment
func (mmPostPayment *mPaymentStorageMockPostPayment) Expect(thePayment Payment) *mPaymentStorageMockPostPayment {
	if mmPostPayment.mock.funcPostPayment != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by Set")
	}

	if mmPostPayment.defaultExpectation == nil {
		mmPostPayment.defaultExpectation = &PaymentStorageMockPostPaymentExpectation{}
	}

	if mmPostPayment.defaultExpectation.paramPtrs != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by ExpectParams functions")
	}

	mmPostPayment.defaultExpectation.params = &PaymentStorageMockPostPaymentParams{thePayment}
	mmPostPayment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPostPayment.expectations {
		if minimock.Equal(e.params, mmPostPayment.defaultExpectation.params) {
			mmPostPayment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPostPayment.defaultExpectation.params)
		}
	}

	return mmPostPayment
}

// ExpectThePaymentParam1 sets up expected param thePayment for paymentStorage.PostPayment
func (mmPostPayment *mPaymentStorageMockPostPayment) ExpectThePaymentParam1(thePayment Payment) *mPaymentStorageMockPostPayment {
	if mmPostPayment.mock.funcPostPayment != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by Set")
	}

	if mmPostPayment.defaultExpectation == nil {
		mmPostPayment.defaultExpectation = &PaymentStorageMockPostPaymentExpectation{}
	}

	if mmPostPayment.defaultExpectation.params != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by Expect")
	}

	if mmPostPayment.defaultExpectation.paramPtrs == nil {
		mmPostPayment.defaultExpectation.paramPtrs = &PaymentStorageMockPostPaymentParamPtrs{}
	}
	mmPostPayment.defaultExpectation.paramPtrs.thePayment = &thePayment
	mmPostPayment.defaultExpectation.expectationOrigins.originThePayment = minimock.CallerInfo(1)

	return mmPostPayment
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.PostPayment
func (mmPostPayment *mPaymentStorageMockPostPayment) Inspect(f func(thePayment Payment)) *mPaymentStorageMockPostPayment {
	if mmPostPayment.mock.inspectFuncPostPayment != nil {
		mmPostPayment.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.PostPayment")
	}

	mmPostPayment.mock.inspectFuncPostPayment = f

	return mmPostPayment
}

// Return sets up results that will be returned by paymentStorage.PostPayment
func (mmPostPayment *mPaymentStorageMockPostPayment) Return(err error) *PaymentStorageMock {
	if mmPostPayment.mock.funcPostPayment != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by Set")
	}

	if mmPostPayment.defaultExpectation == nil {
		mmPostPayment.defaultExpectation = &PaymentStorageMockPostPaymentExpectation{mock: mmPostPayment.mock}
	}
	mmPostPayment.defaultExpectation.results = &PaymentStorageMockPostPaymentResults{err}
	mmPostPayment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPostPayment.mock
}

// Set uses given function f to mock the paymentStorage.PostPayment method
func (mmPostPayment *mPaymentStorageMockPostPayment) Set(f func(thePayment Payment) (err error)) *PaymentStorageMock {
	if mmPostPayment.defaultExpectation != nil {
		mmPostPayment.mock.t.Fatalf("Default expectation is already set for the paymentStorage.PostPayment method")
	}

	if len(mmPostPayment.expectations) > 0 {
		mmPostPayment.mock.t.Fatalf("Some expectations are already set for the paymentStorage.PostPayment method")
	}

	mmPostPayment.mock.funcPostPayment = f
	mmPostPayment.mock.funcPostPaymentOrigin = minimock.CallerInfo(1)
	return mmPostPayment.mock
}

// When sets expectation for the paymentStorage.PostPayment which will trigger the result defined by the following
// Then helper
func (mmPostPayment *mPaymentStorageMockPostPayment) When(thePayment Payment) *PaymentStorageMockPostPaymentExpectation {
	if mmPostPayment.mock.funcPostPayment != nil {
		mmPostPayment.mock.t.Fatalf("PaymentStorageMock.PostPayment mock is already set by Set")
	}

	expectation := &PaymentStorageMockPostPaymentExpectation{
		mock:               mmPostPayment.mock,
		params:             &PaymentStorageMockPostPaymentParams{thePayment},
		expectationOrigins: PaymentStorageMockPostPaymentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPostPayment.expectations = append(mmPostPayment.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.PostPayment return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockPostPaymentExpectation) Then(err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockPostPaymentResults{err}
	return e.mock
}

// Times sets number of times paymentStorage.PostPayment should be invoked
func (mmPostPayment *mPaymentStorageMockPostPayment) Times(n uint64) *mPaymentStorageMockPostPayment {
	if n == 0 {
		mmPostPayment.mock.t.Fatalf("Times of PaymentStorageMock.PostPayment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPostPayment.expectedInvocations, n)
	mmPostPayment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPostPayment
}

func (mmPostPayment *mPaymentStorageMockPostPayment) invocationsDone() bool {
	if len(mmPostPayment.expectations) == 0 && mmPostPayment.defaultExpectation == nil && mmPostPayment.mock.funcPostPayment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPostPayment.mock.afterPostPaymentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPostPayment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PostPayment implements paymentStorage
func (mmPostPayment *PaymentStorageMock) PostPayment(thePayment Payment) (err error) {
	mm_atomic.AddUint64(&mmPostPayment.beforePostPaymentCounter, 1)
	defer mm_atomic.AddUint64(&mmPostPayment.afterPostPaymentCounter, 1)

	mmPostPayment.t.Helper()

	if mmPostPayment.inspectFuncPostPayment != nil {
		mmPostPayment.inspectFuncPostPayment(thePayment)
	}

	mm_params := PaymentStorageMockPostPaymentParams{thePayment}

	// Record call args
	mmPostPayment.PostPaymentMock.mutex.Lock()
	mmPostPayment.PostPaymentMock.callArgs = append(mmPostPayment.PostPaymentMock.callArgs, &mm_params)
	mmPostPayment.PostPaymentMock.mutex.Unlock()

	for _, e := range mmPostPayment.PostPaymentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPostPayment.PostPaymentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPostPayment.PostPaymentMock.defaultExpectation.Counter, 1)
		mm_want := mmPostPayment.PostPaymentMock.defaultExpectation.params
		mm_want_ptrs := mmPostPayment.PostPaymentMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockPostPaymentParams{thePayment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.thePayment != nil && !minimock.Equal(*mm_want_ptrs.thePayment, mm_got.thePayment) {
				mmPostPayment.t.Errorf("PaymentStorageMock.PostPayment got unexpected parameter thePayment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPostPayment.PostPaymentMock.defaultExpectation.expectationOrigins.originThePayment, *mm_want_ptrs.thePayment, mm_got.thePayment, minimock.Diff(*mm_want_ptrs.thePayment, mm_got.thePayment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPostPayment.t.Errorf("PaymentStorageMock.PostPayment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPostPayment.PostPaymentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPostPayment.PostPaymentMock.defaultExpectation.results
		if mm_results == nil {
			mmPostPayment.t.Fatal("No results are set for the PaymentStorageMock.PostPayment")
		}
		return (*mm_results).err
	}
	if mmPostPayment.funcPostPayment != nil {
		return mmPostPayment.funcPostPayment(thePayment)
	}
	mmPostPayment.t.Fatalf("Unexpected call to PaymentStorageMock.PostPayment. %v", thePayment)
	return
}

// PostPaymentAfterCounter returns a count of finished PaymentStorageMock.PostPayment invocations
func (mmPostPayment *PaymentStorageMock) PostPaymentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostPayment.afterPostPaymentCounter)
}

// PostPaymentBeforeCounter returns a count of PaymentStorageMock.PostPayment invocations
func (mmPostPayment *PaymentStorageMock) PostPaymentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostPayment.beforePostPaymentCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.PostPayment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPostPayment *mPaymentStorageMockPostPayment) Calls() []*PaymentStorageMockPostPaymentParams {
	mmPostPayment.mutex.RLock()

	argCopy := make([]*PaymentStorageMockPostPaymentParams, len(mmPostPayment.callArgs))
	copy(argCopy, mmPostPayment.callArgs)

	mmPostPayment.mutex.RUnlock()

	return argCopy
}

// MinimockPostPaymentDone returns true if the count of the PostPayment invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockPostPaymentDone() bool {
	if m.PostPaymentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PostPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PostPaymentMock.invocationsDone()
}

// MinimockPostPaymentInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockPostPaymentInspect() {
	for _, e := range m.PostPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.PostPayment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPostPaymentCounter := mm_atomic.LoadUint64(&m.afterPostPaymentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PostPaymentMock.defaultExpectation != nil && afterPostPaymentCounter < 1 {
		if m.PostPaymentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.PostPayment at\n%s", m.PostPaymentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.PostPayment at\n%s with params: %#v", m.PostPaymentMock.defaultExpectation.expectationOrigins.origin, *m.PostPaymentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostPayment != nil && afterPostPaymentCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.PostPayment at\n%s", m.funcPostPaymentOrigin)
	}

	if !m.PostPaymentMock.invocationsDone() && afterPostPaymentCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.PostPayment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PostPaymentMock.expectedInvocations), m.PostPaymentMock.expectedInvocationsOrigin, afterPostPaymentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelPaymentInspect()

			m.MinimockGetPaymentInspect()

			m.MinimockPostPaymentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelPaymentDone() &&
		m.MinimockGetPaymentDone() &&
		m.MinimockPostPaymentDone()
}
