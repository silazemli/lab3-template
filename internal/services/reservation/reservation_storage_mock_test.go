// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package reservation

//go:generate minimock -i github.com/silazemli/lab2-template/internal/services/reservation.reservationStorage -o reservation_storage_mock_test.go -n ReservationStorageMock -p reservation

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ReservationStorageMock implements reservationStorage
type ReservationStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelReservation          func(reservationUID string) (err error)
	funcCancelReservationOrigin    string
	inspectFuncCancelReservation   func(reservationUID string)
	afterCancelReservationCounter  uint64
	beforeCancelReservationCounter uint64
	CancelReservationMock          mReservationStorageMockCancelReservation

	funcGetReservation          func(reservationUID string) (r1 Reservation, err error)
	funcGetReservationOrigin    string
	inspectFuncGetReservation   func(reservationUID string)
	afterGetReservationCounter  uint64
	beforeGetReservationCounter uint64
	GetReservationMock          mReservationStorageMockGetReservation

	funcGetReservations          func(username string) (ra1 []Reservation, err error)
	funcGetReservationsOrigin    string
	inspectFuncGetReservations   func(username string)
	afterGetReservationsCounter  uint64
	beforeGetReservationsCounter uint64
	GetReservationsMock          mReservationStorageMockGetReservations

	funcMakeReservation          func(reservation Reservation) (err error)
	funcMakeReservationOrigin    string
	inspectFuncMakeReservation   func(reservation Reservation)
	afterMakeReservationCounter  uint64
	beforeMakeReservationCounter uint64
	MakeReservationMock          mReservationStorageMockMakeReservation
}

// NewReservationStorageMock returns a mock for reservationStorage
func NewReservationStorageMock(t minimock.Tester) *ReservationStorageMock {
	m := &ReservationStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelReservationMock = mReservationStorageMockCancelReservation{mock: m}
	m.CancelReservationMock.callArgs = []*ReservationStorageMockCancelReservationParams{}

	m.GetReservationMock = mReservationStorageMockGetReservation{mock: m}
	m.GetReservationMock.callArgs = []*ReservationStorageMockGetReservationParams{}

	m.GetReservationsMock = mReservationStorageMockGetReservations{mock: m}
	m.GetReservationsMock.callArgs = []*ReservationStorageMockGetReservationsParams{}

	m.MakeReservationMock = mReservationStorageMockMakeReservation{mock: m}
	m.MakeReservationMock.callArgs = []*ReservationStorageMockMakeReservationParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReservationStorageMockCancelReservation struct {
	optional           bool
	mock               *ReservationStorageMock
	defaultExpectation *ReservationStorageMockCancelReservationExpectation
	expectations       []*ReservationStorageMockCancelReservationExpectation

	callArgs []*ReservationStorageMockCancelReservationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReservationStorageMockCancelReservationExpectation specifies expectation struct of the reservationStorage.CancelReservation
type ReservationStorageMockCancelReservationExpectation struct {
	mock               *ReservationStorageMock
	params             *ReservationStorageMockCancelReservationParams
	paramPtrs          *ReservationStorageMockCancelReservationParamPtrs
	expectationOrigins ReservationStorageMockCancelReservationExpectationOrigins
	results            *ReservationStorageMockCancelReservationResults
	returnOrigin       string
	Counter            uint64
}

// ReservationStorageMockCancelReservationParams contains parameters of the reservationStorage.CancelReservation
type ReservationStorageMockCancelReservationParams struct {
	reservationUID string
}

// ReservationStorageMockCancelReservationParamPtrs contains pointers to parameters of the reservationStorage.CancelReservation
type ReservationStorageMockCancelReservationParamPtrs struct {
	reservationUID *string
}

// ReservationStorageMockCancelReservationResults contains results of the reservationStorage.CancelReservation
type ReservationStorageMockCancelReservationResults struct {
	err error
}

// ReservationStorageMockCancelReservationOrigins contains origins of expectations of the reservationStorage.CancelReservation
type ReservationStorageMockCancelReservationExpectationOrigins struct {
	origin               string
	originReservationUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelReservation *mReservationStorageMockCancelReservation) Optional() *mReservationStorageMockCancelReservation {
	mmCancelReservation.optional = true
	return mmCancelReservation
}

// Expect sets up expected params for reservationStorage.CancelReservation
func (mmCancelReservation *mReservationStorageMockCancelReservation) Expect(reservationUID string) *mReservationStorageMockCancelReservation {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by Set")
	}

	if mmCancelReservation.defaultExpectation == nil {
		mmCancelReservation.defaultExpectation = &ReservationStorageMockCancelReservationExpectation{}
	}

	if mmCancelReservation.defaultExpectation.paramPtrs != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by ExpectParams functions")
	}

	mmCancelReservation.defaultExpectation.params = &ReservationStorageMockCancelReservationParams{reservationUID}
	mmCancelReservation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelReservation.expectations {
		if minimock.Equal(e.params, mmCancelReservation.defaultExpectation.params) {
			mmCancelReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReservation.defaultExpectation.params)
		}
	}

	return mmCancelReservation
}

// ExpectReservationUIDParam1 sets up expected param reservationUID for reservationStorage.CancelReservation
func (mmCancelReservation *mReservationStorageMockCancelReservation) ExpectReservationUIDParam1(reservationUID string) *mReservationStorageMockCancelReservation {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by Set")
	}

	if mmCancelReservation.defaultExpectation == nil {
		mmCancelReservation.defaultExpectation = &ReservationStorageMockCancelReservationExpectation{}
	}

	if mmCancelReservation.defaultExpectation.params != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by Expect")
	}

	if mmCancelReservation.defaultExpectation.paramPtrs == nil {
		mmCancelReservation.defaultExpectation.paramPtrs = &ReservationStorageMockCancelReservationParamPtrs{}
	}
	mmCancelReservation.defaultExpectation.paramPtrs.reservationUID = &reservationUID
	mmCancelReservation.defaultExpectation.expectationOrigins.originReservationUID = minimock.CallerInfo(1)

	return mmCancelReservation
}

// Inspect accepts an inspector function that has same arguments as the reservationStorage.CancelReservation
func (mmCancelReservation *mReservationStorageMockCancelReservation) Inspect(f func(reservationUID string)) *mReservationStorageMockCancelReservation {
	if mmCancelReservation.mock.inspectFuncCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("Inspect function is already set for ReservationStorageMock.CancelReservation")
	}

	mmCancelReservation.mock.inspectFuncCancelReservation = f

	return mmCancelReservation
}

// Return sets up results that will be returned by reservationStorage.CancelReservation
func (mmCancelReservation *mReservationStorageMockCancelReservation) Return(err error) *ReservationStorageMock {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by Set")
	}

	if mmCancelReservation.defaultExpectation == nil {
		mmCancelReservation.defaultExpectation = &ReservationStorageMockCancelReservationExpectation{mock: mmCancelReservation.mock}
	}
	mmCancelReservation.defaultExpectation.results = &ReservationStorageMockCancelReservationResults{err}
	mmCancelReservation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelReservation.mock
}

// Set uses given function f to mock the reservationStorage.CancelReservation method
func (mmCancelReservation *mReservationStorageMockCancelReservation) Set(f func(reservationUID string) (err error)) *ReservationStorageMock {
	if mmCancelReservation.defaultExpectation != nil {
		mmCancelReservation.mock.t.Fatalf("Default expectation is already set for the reservationStorage.CancelReservation method")
	}

	if len(mmCancelReservation.expectations) > 0 {
		mmCancelReservation.mock.t.Fatalf("Some expectations are already set for the reservationStorage.CancelReservation method")
	}

	mmCancelReservation.mock.funcCancelReservation = f
	mmCancelReservation.mock.funcCancelReservationOrigin = minimock.CallerInfo(1)
	return mmCancelReservation.mock
}

// When sets expectation for the reservationStorage.CancelReservation which will trigger the result defined by the following
// Then helper
func (mmCancelReservation *mReservationStorageMockCancelReservation) When(reservationUID string) *ReservationStorageMockCancelReservationExpectation {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("ReservationStorageMock.CancelReservation mock is already set by Set")
	}

	expectation := &ReservationStorageMockCancelReservationExpectation{
		mock:               mmCancelReservation.mock,
		params:             &ReservationStorageMockCancelReservationParams{reservationUID},
		expectationOrigins: ReservationStorageMockCancelReservationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelReservation.expectations = append(mmCancelReservation.expectations, expectation)
	return expectation
}

// Then sets up reservationStorage.CancelReservation return parameters for the expectation previously defined by the When method
func (e *ReservationStorageMockCancelReservationExpectation) Then(err error) *ReservationStorageMock {
	e.results = &ReservationStorageMockCancelReservationResults{err}
	return e.mock
}

// Times sets number of times reservationStorage.CancelReservation should be invoked
func (mmCancelReservation *mReservationStorageMockCancelReservation) Times(n uint64) *mReservationStorageMockCancelReservation {
	if n == 0 {
		mmCancelReservation.mock.t.Fatalf("Times of ReservationStorageMock.CancelReservation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelReservation.expectedInvocations, n)
	mmCancelReservation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelReservation
}

func (mmCancelReservation *mReservationStorageMockCancelReservation) invocationsDone() bool {
	if len(mmCancelReservation.expectations) == 0 && mmCancelReservation.defaultExpectation == nil && mmCancelReservation.mock.funcCancelReservation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelReservation.mock.afterCancelReservationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelReservation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelReservation implements reservationStorage
func (mmCancelReservation *ReservationStorageMock) CancelReservation(reservationUID string) (err error) {
	mm_atomic.AddUint64(&mmCancelReservation.beforeCancelReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReservation.afterCancelReservationCounter, 1)

	mmCancelReservation.t.Helper()

	if mmCancelReservation.inspectFuncCancelReservation != nil {
		mmCancelReservation.inspectFuncCancelReservation(reservationUID)
	}

	mm_params := ReservationStorageMockCancelReservationParams{reservationUID}

	// Record call args
	mmCancelReservation.CancelReservationMock.mutex.Lock()
	mmCancelReservation.CancelReservationMock.callArgs = append(mmCancelReservation.CancelReservationMock.callArgs, &mm_params)
	mmCancelReservation.CancelReservationMock.mutex.Unlock()

	for _, e := range mmCancelReservation.CancelReservationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReservation.CancelReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReservation.CancelReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReservation.CancelReservationMock.defaultExpectation.params
		mm_want_ptrs := mmCancelReservation.CancelReservationMock.defaultExpectation.paramPtrs

		mm_got := ReservationStorageMockCancelReservationParams{reservationUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.reservationUID != nil && !minimock.Equal(*mm_want_ptrs.reservationUID, mm_got.reservationUID) {
				mmCancelReservation.t.Errorf("ReservationStorageMock.CancelReservation got unexpected parameter reservationUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReservation.CancelReservationMock.defaultExpectation.expectationOrigins.originReservationUID, *mm_want_ptrs.reservationUID, mm_got.reservationUID, minimock.Diff(*mm_want_ptrs.reservationUID, mm_got.reservationUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReservation.t.Errorf("ReservationStorageMock.CancelReservation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelReservation.CancelReservationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReservation.CancelReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReservation.t.Fatal("No results are set for the ReservationStorageMock.CancelReservation")
		}
		return (*mm_results).err
	}
	if mmCancelReservation.funcCancelReservation != nil {
		return mmCancelReservation.funcCancelReservation(reservationUID)
	}
	mmCancelReservation.t.Fatalf("Unexpected call to ReservationStorageMock.CancelReservation. %v", reservationUID)
	return
}

// CancelReservationAfterCounter returns a count of finished ReservationStorageMock.CancelReservation invocations
func (mmCancelReservation *ReservationStorageMock) CancelReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservation.afterCancelReservationCounter)
}

// CancelReservationBeforeCounter returns a count of ReservationStorageMock.CancelReservation invocations
func (mmCancelReservation *ReservationStorageMock) CancelReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservation.beforeCancelReservationCounter)
}

// Calls returns a list of arguments used in each call to ReservationStorageMock.CancelReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReservation *mReservationStorageMockCancelReservation) Calls() []*ReservationStorageMockCancelReservationParams {
	mmCancelReservation.mutex.RLock()

	argCopy := make([]*ReservationStorageMockCancelReservationParams, len(mmCancelReservation.callArgs))
	copy(argCopy, mmCancelReservation.callArgs)

	mmCancelReservation.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReservationDone returns true if the count of the CancelReservation invocations corresponds
// the number of defined expectations
func (m *ReservationStorageMock) MinimockCancelReservationDone() bool {
	if m.CancelReservationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelReservationMock.invocationsDone()
}

// MinimockCancelReservationInspect logs each unmet expectation
func (m *ReservationStorageMock) MinimockCancelReservationInspect() {
	for _, e := range m.CancelReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReservationStorageMock.CancelReservation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelReservationCounter := mm_atomic.LoadUint64(&m.afterCancelReservationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReservationMock.defaultExpectation != nil && afterCancelReservationCounter < 1 {
		if m.CancelReservationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReservationStorageMock.CancelReservation at\n%s", m.CancelReservationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReservationStorageMock.CancelReservation at\n%s with params: %#v", m.CancelReservationMock.defaultExpectation.expectationOrigins.origin, *m.CancelReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReservation != nil && afterCancelReservationCounter < 1 {
		m.t.Errorf("Expected call to ReservationStorageMock.CancelReservation at\n%s", m.funcCancelReservationOrigin)
	}

	if !m.CancelReservationMock.invocationsDone() && afterCancelReservationCounter > 0 {
		m.t.Errorf("Expected %d calls to ReservationStorageMock.CancelReservation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelReservationMock.expectedInvocations), m.CancelReservationMock.expectedInvocationsOrigin, afterCancelReservationCounter)
	}
}

type mReservationStorageMockGetReservation struct {
	optional           bool
	mock               *ReservationStorageMock
	defaultExpectation *ReservationStorageMockGetReservationExpectation
	expectations       []*ReservationStorageMockGetReservationExpectation

	callArgs []*ReservationStorageMockGetReservationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReservationStorageMockGetReservationExpectation specifies expectation struct of the reservationStorage.GetReservation
type ReservationStorageMockGetReservationExpectation struct {
	mock               *ReservationStorageMock
	params             *ReservationStorageMockGetReservationParams
	paramPtrs          *ReservationStorageMockGetReservationParamPtrs
	expectationOrigins ReservationStorageMockGetReservationExpectationOrigins
	results            *ReservationStorageMockGetReservationResults
	returnOrigin       string
	Counter            uint64
}

// ReservationStorageMockGetReservationParams contains parameters of the reservationStorage.GetReservation
type ReservationStorageMockGetReservationParams struct {
	reservationUID string
}

// ReservationStorageMockGetReservationParamPtrs contains pointers to parameters of the reservationStorage.GetReservation
type ReservationStorageMockGetReservationParamPtrs struct {
	reservationUID *string
}

// ReservationStorageMockGetReservationResults contains results of the reservationStorage.GetReservation
type ReservationStorageMockGetReservationResults struct {
	r1  Reservation
	err error
}

// ReservationStorageMockGetReservationOrigins contains origins of expectations of the reservationStorage.GetReservation
type ReservationStorageMockGetReservationExpectationOrigins struct {
	origin               string
	originReservationUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReservation *mReservationStorageMockGetReservation) Optional() *mReservationStorageMockGetReservation {
	mmGetReservation.optional = true
	return mmGetReservation
}

// Expect sets up expected params for reservationStorage.GetReservation
func (mmGetReservation *mReservationStorageMockGetReservation) Expect(reservationUID string) *mReservationStorageMockGetReservation {
	if mmGetReservation.mock.funcGetReservation != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by Set")
	}

	if mmGetReservation.defaultExpectation == nil {
		mmGetReservation.defaultExpectation = &ReservationStorageMockGetReservationExpectation{}
	}

	if mmGetReservation.defaultExpectation.paramPtrs != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by ExpectParams functions")
	}

	mmGetReservation.defaultExpectation.params = &ReservationStorageMockGetReservationParams{reservationUID}
	mmGetReservation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReservation.expectations {
		if minimock.Equal(e.params, mmGetReservation.defaultExpectation.params) {
			mmGetReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReservation.defaultExpectation.params)
		}
	}

	return mmGetReservation
}

// ExpectReservationUIDParam1 sets up expected param reservationUID for reservationStorage.GetReservation
func (mmGetReservation *mReservationStorageMockGetReservation) ExpectReservationUIDParam1(reservationUID string) *mReservationStorageMockGetReservation {
	if mmGetReservation.mock.funcGetReservation != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by Set")
	}

	if mmGetReservation.defaultExpectation == nil {
		mmGetReservation.defaultExpectation = &ReservationStorageMockGetReservationExpectation{}
	}

	if mmGetReservation.defaultExpectation.params != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by Expect")
	}

	if mmGetReservation.defaultExpectation.paramPtrs == nil {
		mmGetReservation.defaultExpectation.paramPtrs = &ReservationStorageMockGetReservationParamPtrs{}
	}
	mmGetReservation.defaultExpectation.paramPtrs.reservationUID = &reservationUID
	mmGetReservation.defaultExpectation.expectationOrigins.originReservationUID = minimock.CallerInfo(1)

	return mmGetReservation
}

// Inspect accepts an inspector function that has same arguments as the reservationStorage.GetReservation
func (mmGetReservation *mReservationStorageMockGetReservation) Inspect(f func(reservationUID string)) *mReservationStorageMockGetReservation {
	if mmGetReservation.mock.inspectFuncGetReservation != nil {
		mmGetReservation.mock.t.Fatalf("Inspect function is already set for ReservationStorageMock.GetReservation")
	}

	mmGetReservation.mock.inspectFuncGetReservation = f

	return mmGetReservation
}

// Return sets up results that will be returned by reservationStorage.GetReservation
func (mmGetReservation *mReservationStorageMockGetReservation) Return(r1 Reservation, err error) *ReservationStorageMock {
	if mmGetReservation.mock.funcGetReservation != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by Set")
	}

	if mmGetReservation.defaultExpectation == nil {
		mmGetReservation.defaultExpectation = &ReservationStorageMockGetReservationExpectation{mock: mmGetReservation.mock}
	}
	mmGetReservation.defaultExpectation.results = &ReservationStorageMockGetReservationResults{r1, err}
	mmGetReservation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReservation.mock
}

// Set uses given function f to mock the reservationStorage.GetReservation method
func (mmGetReservation *mReservationStorageMockGetReservation) Set(f func(reservationUID string) (r1 Reservation, err error)) *ReservationStorageMock {
	if mmGetReservation.defaultExpectation != nil {
		mmGetReservation.mock.t.Fatalf("Default expectation is already set for the reservationStorage.GetReservation method")
	}

	if len(mmGetReservation.expectations) > 0 {
		mmGetReservation.mock.t.Fatalf("Some expectations are already set for the reservationStorage.GetReservation method")
	}

	mmGetReservation.mock.funcGetReservation = f
	mmGetReservation.mock.funcGetReservationOrigin = minimock.CallerInfo(1)
	return mmGetReservation.mock
}

// When sets expectation for the reservationStorage.GetReservation which will trigger the result defined by the following
// Then helper
func (mmGetReservation *mReservationStorageMockGetReservation) When(reservationUID string) *ReservationStorageMockGetReservationExpectation {
	if mmGetReservation.mock.funcGetReservation != nil {
		mmGetReservation.mock.t.Fatalf("ReservationStorageMock.GetReservation mock is already set by Set")
	}

	expectation := &ReservationStorageMockGetReservationExpectation{
		mock:               mmGetReservation.mock,
		params:             &ReservationStorageMockGetReservationParams{reservationUID},
		expectationOrigins: ReservationStorageMockGetReservationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReservation.expectations = append(mmGetReservation.expectations, expectation)
	return expectation
}

// Then sets up reservationStorage.GetReservation return parameters for the expectation previously defined by the When method
func (e *ReservationStorageMockGetReservationExpectation) Then(r1 Reservation, err error) *ReservationStorageMock {
	e.results = &ReservationStorageMockGetReservationResults{r1, err}
	return e.mock
}

// Times sets number of times reservationStorage.GetReservation should be invoked
func (mmGetReservation *mReservationStorageMockGetReservation) Times(n uint64) *mReservationStorageMockGetReservation {
	if n == 0 {
		mmGetReservation.mock.t.Fatalf("Times of ReservationStorageMock.GetReservation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReservation.expectedInvocations, n)
	mmGetReservation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReservation
}

func (mmGetReservation *mReservationStorageMockGetReservation) invocationsDone() bool {
	if len(mmGetReservation.expectations) == 0 && mmGetReservation.defaultExpectation == nil && mmGetReservation.mock.funcGetReservation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReservation.mock.afterGetReservationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReservation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReservation implements reservationStorage
func (mmGetReservation *ReservationStorageMock) GetReservation(reservationUID string) (r1 Reservation, err error) {
	mm_atomic.AddUint64(&mmGetReservation.beforeGetReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReservation.afterGetReservationCounter, 1)

	mmGetReservation.t.Helper()

	if mmGetReservation.inspectFuncGetReservation != nil {
		mmGetReservation.inspectFuncGetReservation(reservationUID)
	}

	mm_params := ReservationStorageMockGetReservationParams{reservationUID}

	// Record call args
	mmGetReservation.GetReservationMock.mutex.Lock()
	mmGetReservation.GetReservationMock.callArgs = append(mmGetReservation.GetReservationMock.callArgs, &mm_params)
	mmGetReservation.GetReservationMock.mutex.Unlock()

	for _, e := range mmGetReservation.GetReservationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetReservation.GetReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReservation.GetReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReservation.GetReservationMock.defaultExpectation.params
		mm_want_ptrs := mmGetReservation.GetReservationMock.defaultExpectation.paramPtrs

		mm_got := ReservationStorageMockGetReservationParams{reservationUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.reservationUID != nil && !minimock.Equal(*mm_want_ptrs.reservationUID, mm_got.reservationUID) {
				mmGetReservation.t.Errorf("ReservationStorageMock.GetReservation got unexpected parameter reservationUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReservation.GetReservationMock.defaultExpectation.expectationOrigins.originReservationUID, *mm_want_ptrs.reservationUID, mm_got.reservationUID, minimock.Diff(*mm_want_ptrs.reservationUID, mm_got.reservationUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReservation.t.Errorf("ReservationStorageMock.GetReservation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReservation.GetReservationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReservation.GetReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReservation.t.Fatal("No results are set for the ReservationStorageMock.GetReservation")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetReservation.funcGetReservation != nil {
		return mmGetReservation.funcGetReservation(reservationUID)
	}
	mmGetReservation.t.Fatalf("Unexpected call to ReservationStorageMock.GetReservation. %v", reservationUID)
	return
}

// GetReservationAfterCounter returns a count of finished ReservationStorageMock.GetReservation invocations
func (mmGetReservation *ReservationStorageMock) GetReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReservation.afterGetReservationCounter)
}

// GetReservationBeforeCounter returns a count of ReservationStorageMock.GetReservation invocations
func (mmGetReservation *ReservationStorageMock) GetReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReservation.beforeGetReservationCounter)
}

// Calls returns a list of arguments used in each call to ReservationStorageMock.GetReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReservation *mReservationStorageMockGetReservation) Calls() []*ReservationStorageMockGetReservationParams {
	mmGetReservation.mutex.RLock()

	argCopy := make([]*ReservationStorageMockGetReservationParams, len(mmGetReservation.callArgs))
	copy(argCopy, mmGetReservation.callArgs)

	mmGetReservation.mutex.RUnlock()

	return argCopy
}

// MinimockGetReservationDone returns true if the count of the GetReservation invocations corresponds
// the number of defined expectations
func (m *ReservationStorageMock) MinimockGetReservationDone() bool {
	if m.GetReservationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReservationMock.invocationsDone()
}

// MinimockGetReservationInspect logs each unmet expectation
func (m *ReservationStorageMock) MinimockGetReservationInspect() {
	for _, e := range m.GetReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReservationCounter := mm_atomic.LoadUint64(&m.afterGetReservationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReservationMock.defaultExpectation != nil && afterGetReservationCounter < 1 {
		if m.GetReservationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservation at\n%s", m.GetReservationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservation at\n%s with params: %#v", m.GetReservationMock.defaultExpectation.expectationOrigins.origin, *m.GetReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReservation != nil && afterGetReservationCounter < 1 {
		m.t.Errorf("Expected call to ReservationStorageMock.GetReservation at\n%s", m.funcGetReservationOrigin)
	}

	if !m.GetReservationMock.invocationsDone() && afterGetReservationCounter > 0 {
		m.t.Errorf("Expected %d calls to ReservationStorageMock.GetReservation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReservationMock.expectedInvocations), m.GetReservationMock.expectedInvocationsOrigin, afterGetReservationCounter)
	}
}

type mReservationStorageMockGetReservations struct {
	optional           bool
	mock               *ReservationStorageMock
	defaultExpectation *ReservationStorageMockGetReservationsExpectation
	expectations       []*ReservationStorageMockGetReservationsExpectation

	callArgs []*ReservationStorageMockGetReservationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReservationStorageMockGetReservationsExpectation specifies expectation struct of the reservationStorage.GetReservations
type ReservationStorageMockGetReservationsExpectation struct {
	mock               *ReservationStorageMock
	params             *ReservationStorageMockGetReservationsParams
	paramPtrs          *ReservationStorageMockGetReservationsParamPtrs
	expectationOrigins ReservationStorageMockGetReservationsExpectationOrigins
	results            *ReservationStorageMockGetReservationsResults
	returnOrigin       string
	Counter            uint64
}

// ReservationStorageMockGetReservationsParams contains parameters of the reservationStorage.GetReservations
type ReservationStorageMockGetReservationsParams struct {
	username string
}

// ReservationStorageMockGetReservationsParamPtrs contains pointers to parameters of the reservationStorage.GetReservations
type ReservationStorageMockGetReservationsParamPtrs struct {
	username *string
}

// ReservationStorageMockGetReservationsResults contains results of the reservationStorage.GetReservations
type ReservationStorageMockGetReservationsResults struct {
	ra1 []Reservation
	err error
}

// ReservationStorageMockGetReservationsOrigins contains origins of expectations of the reservationStorage.GetReservations
type ReservationStorageMockGetReservationsExpectationOrigins struct {
	origin         string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReservations *mReservationStorageMockGetReservations) Optional() *mReservationStorageMockGetReservations {
	mmGetReservations.optional = true
	return mmGetReservations
}

// Expect sets up expected params for reservationStorage.GetReservations
func (mmGetReservations *mReservationStorageMockGetReservations) Expect(username string) *mReservationStorageMockGetReservations {
	if mmGetReservations.mock.funcGetReservations != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by Set")
	}

	if mmGetReservations.defaultExpectation == nil {
		mmGetReservations.defaultExpectation = &ReservationStorageMockGetReservationsExpectation{}
	}

	if mmGetReservations.defaultExpectation.paramPtrs != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by ExpectParams functions")
	}

	mmGetReservations.defaultExpectation.params = &ReservationStorageMockGetReservationsParams{username}
	mmGetReservations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReservations.expectations {
		if minimock.Equal(e.params, mmGetReservations.defaultExpectation.params) {
			mmGetReservations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReservations.defaultExpectation.params)
		}
	}

	return mmGetReservations
}

// ExpectUsernameParam1 sets up expected param username for reservationStorage.GetReservations
func (mmGetReservations *mReservationStorageMockGetReservations) ExpectUsernameParam1(username string) *mReservationStorageMockGetReservations {
	if mmGetReservations.mock.funcGetReservations != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by Set")
	}

	if mmGetReservations.defaultExpectation == nil {
		mmGetReservations.defaultExpectation = &ReservationStorageMockGetReservationsExpectation{}
	}

	if mmGetReservations.defaultExpectation.params != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by Expect")
	}

	if mmGetReservations.defaultExpectation.paramPtrs == nil {
		mmGetReservations.defaultExpectation.paramPtrs = &ReservationStorageMockGetReservationsParamPtrs{}
	}
	mmGetReservations.defaultExpectation.paramPtrs.username = &username
	mmGetReservations.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetReservations
}

// Inspect accepts an inspector function that has same arguments as the reservationStorage.GetReservations
func (mmGetReservations *mReservationStorageMockGetReservations) Inspect(f func(username string)) *mReservationStorageMockGetReservations {
	if mmGetReservations.mock.inspectFuncGetReservations != nil {
		mmGetReservations.mock.t.Fatalf("Inspect function is already set for ReservationStorageMock.GetReservations")
	}

	mmGetReservations.mock.inspectFuncGetReservations = f

	return mmGetReservations
}

// Return sets up results that will be returned by reservationStorage.GetReservations
func (mmGetReservations *mReservationStorageMockGetReservations) Return(ra1 []Reservation, err error) *ReservationStorageMock {
	if mmGetReservations.mock.funcGetReservations != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by Set")
	}

	if mmGetReservations.defaultExpectation == nil {
		mmGetReservations.defaultExpectation = &ReservationStorageMockGetReservationsExpectation{mock: mmGetReservations.mock}
	}
	mmGetReservations.defaultExpectation.results = &ReservationStorageMockGetReservationsResults{ra1, err}
	mmGetReservations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReservations.mock
}

// Set uses given function f to mock the reservationStorage.GetReservations method
func (mmGetReservations *mReservationStorageMockGetReservations) Set(f func(username string) (ra1 []Reservation, err error)) *ReservationStorageMock {
	if mmGetReservations.defaultExpectation != nil {
		mmGetReservations.mock.t.Fatalf("Default expectation is already set for the reservationStorage.GetReservations method")
	}

	if len(mmGetReservations.expectations) > 0 {
		mmGetReservations.mock.t.Fatalf("Some expectations are already set for the reservationStorage.GetReservations method")
	}

	mmGetReservations.mock.funcGetReservations = f
	mmGetReservations.mock.funcGetReservationsOrigin = minimock.CallerInfo(1)
	return mmGetReservations.mock
}

// When sets expectation for the reservationStorage.GetReservations which will trigger the result defined by the following
// Then helper
func (mmGetReservations *mReservationStorageMockGetReservations) When(username string) *ReservationStorageMockGetReservationsExpectation {
	if mmGetReservations.mock.funcGetReservations != nil {
		mmGetReservations.mock.t.Fatalf("ReservationStorageMock.GetReservations mock is already set by Set")
	}

	expectation := &ReservationStorageMockGetReservationsExpectation{
		mock:               mmGetReservations.mock,
		params:             &ReservationStorageMockGetReservationsParams{username},
		expectationOrigins: ReservationStorageMockGetReservationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReservations.expectations = append(mmGetReservations.expectations, expectation)
	return expectation
}

// Then sets up reservationStorage.GetReservations return parameters for the expectation previously defined by the When method
func (e *ReservationStorageMockGetReservationsExpectation) Then(ra1 []Reservation, err error) *ReservationStorageMock {
	e.results = &ReservationStorageMockGetReservationsResults{ra1, err}
	return e.mock
}

// Times sets number of times reservationStorage.GetReservations should be invoked
func (mmGetReservations *mReservationStorageMockGetReservations) Times(n uint64) *mReservationStorageMockGetReservations {
	if n == 0 {
		mmGetReservations.mock.t.Fatalf("Times of ReservationStorageMock.GetReservations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReservations.expectedInvocations, n)
	mmGetReservations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReservations
}

func (mmGetReservations *mReservationStorageMockGetReservations) invocationsDone() bool {
	if len(mmGetReservations.expectations) == 0 && mmGetReservations.defaultExpectation == nil && mmGetReservations.mock.funcGetReservations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReservations.mock.afterGetReservationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReservations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReservations implements reservationStorage
func (mmGetReservations *ReservationStorageMock) GetReservations(username string) (ra1 []Reservation, err error) {
	mm_atomic.AddUint64(&mmGetReservations.beforeGetReservationsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReservations.afterGetReservationsCounter, 1)

	mmGetReservations.t.Helper()

	if mmGetReservations.inspectFuncGetReservations != nil {
		mmGetReservations.inspectFuncGetReservations(username)
	}

	mm_params := ReservationStorageMockGetReservationsParams{username}

	// Record call args
	mmGetReservations.GetReservationsMock.mutex.Lock()
	mmGetReservations.GetReservationsMock.callArgs = append(mmGetReservations.GetReservationsMock.callArgs, &mm_params)
	mmGetReservations.GetReservationsMock.mutex.Unlock()

	for _, e := range mmGetReservations.GetReservationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetReservations.GetReservationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReservations.GetReservationsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReservations.GetReservationsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReservations.GetReservationsMock.defaultExpectation.paramPtrs

		mm_got := ReservationStorageMockGetReservationsParams{username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetReservations.t.Errorf("ReservationStorageMock.GetReservations got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReservations.GetReservationsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReservations.t.Errorf("ReservationStorageMock.GetReservations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReservations.GetReservationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReservations.GetReservationsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReservations.t.Fatal("No results are set for the ReservationStorageMock.GetReservations")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmGetReservations.funcGetReservations != nil {
		return mmGetReservations.funcGetReservations(username)
	}
	mmGetReservations.t.Fatalf("Unexpected call to ReservationStorageMock.GetReservations. %v", username)
	return
}

// GetReservationsAfterCounter returns a count of finished ReservationStorageMock.GetReservations invocations
func (mmGetReservations *ReservationStorageMock) GetReservationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReservations.afterGetReservationsCounter)
}

// GetReservationsBeforeCounter returns a count of ReservationStorageMock.GetReservations invocations
func (mmGetReservations *ReservationStorageMock) GetReservationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReservations.beforeGetReservationsCounter)
}

// Calls returns a list of arguments used in each call to ReservationStorageMock.GetReservations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReservations *mReservationStorageMockGetReservations) Calls() []*ReservationStorageMockGetReservationsParams {
	mmGetReservations.mutex.RLock()

	argCopy := make([]*ReservationStorageMockGetReservationsParams, len(mmGetReservations.callArgs))
	copy(argCopy, mmGetReservations.callArgs)

	mmGetReservations.mutex.RUnlock()

	return argCopy
}

// MinimockGetReservationsDone returns true if the count of the GetReservations invocations corresponds
// the number of defined expectations
func (m *ReservationStorageMock) MinimockGetReservationsDone() bool {
	if m.GetReservationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReservationsMock.invocationsDone()
}

// MinimockGetReservationsInspect logs each unmet expectation
func (m *ReservationStorageMock) MinimockGetReservationsInspect() {
	for _, e := range m.GetReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReservationsCounter := mm_atomic.LoadUint64(&m.afterGetReservationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReservationsMock.defaultExpectation != nil && afterGetReservationsCounter < 1 {
		if m.GetReservationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservations at\n%s", m.GetReservationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReservationStorageMock.GetReservations at\n%s with params: %#v", m.GetReservationsMock.defaultExpectation.expectationOrigins.origin, *m.GetReservationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReservations != nil && afterGetReservationsCounter < 1 {
		m.t.Errorf("Expected call to ReservationStorageMock.GetReservations at\n%s", m.funcGetReservationsOrigin)
	}

	if !m.GetReservationsMock.invocationsDone() && afterGetReservationsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReservationStorageMock.GetReservations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReservationsMock.expectedInvocations), m.GetReservationsMock.expectedInvocationsOrigin, afterGetReservationsCounter)
	}
}

type mReservationStorageMockMakeReservation struct {
	optional           bool
	mock               *ReservationStorageMock
	defaultExpectation *ReservationStorageMockMakeReservationExpectation
	expectations       []*ReservationStorageMockMakeReservationExpectation

	callArgs []*ReservationStorageMockMakeReservationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReservationStorageMockMakeReservationExpectation specifies expectation struct of the reservationStorage.MakeReservation
type ReservationStorageMockMakeReservationExpectation struct {
	mock               *ReservationStorageMock
	params             *ReservationStorageMockMakeReservationParams
	paramPtrs          *ReservationStorageMockMakeReservationParamPtrs
	expectationOrigins ReservationStorageMockMakeReservationExpectationOrigins
	results            *ReservationStorageMockMakeReservationResults
	returnOrigin       string
	Counter            uint64
}

// ReservationStorageMockMakeReservationParams contains parameters of the reservationStorage.MakeReservation
type ReservationStorageMockMakeReservationParams struct {
	reservation Reservation
}

// ReservationStorageMockMakeReservationParamPtrs contains pointers to parameters of the reservationStorage.MakeReservation
type ReservationStorageMockMakeReservationParamPtrs struct {
	reservation *Reservation
}

// ReservationStorageMockMakeReservationResults contains results of the reservationStorage.MakeReservation
type ReservationStorageMockMakeReservationResults struct {
	err error
}

// ReservationStorageMockMakeReservationOrigins contains origins of expectations of the reservationStorage.MakeReservation
type ReservationStorageMockMakeReservationExpectationOrigins struct {
	origin            string
	originReservation string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMakeReservation *mReservationStorageMockMakeReservation) Optional() *mReservationStorageMockMakeReservation {
	mmMakeReservation.optional = true
	return mmMakeReservation
}

// Expect sets up expected params for reservationStorage.MakeReservation
func (mmMakeReservation *mReservationStorageMockMakeReservation) Expect(reservation Reservation) *mReservationStorageMockMakeReservation {
	if mmMakeReservation.mock.funcMakeReservation != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by Set")
	}

	if mmMakeReservation.defaultExpectation == nil {
		mmMakeReservation.defaultExpectation = &ReservationStorageMockMakeReservationExpectation{}
	}

	if mmMakeReservation.defaultExpectation.paramPtrs != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by ExpectParams functions")
	}

	mmMakeReservation.defaultExpectation.params = &ReservationStorageMockMakeReservationParams{reservation}
	mmMakeReservation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMakeReservation.expectations {
		if minimock.Equal(e.params, mmMakeReservation.defaultExpectation.params) {
			mmMakeReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeReservation.defaultExpectation.params)
		}
	}

	return mmMakeReservation
}

// ExpectReservationParam1 sets up expected param reservation for reservationStorage.MakeReservation
func (mmMakeReservation *mReservationStorageMockMakeReservation) ExpectReservationParam1(reservation Reservation) *mReservationStorageMockMakeReservation {
	if mmMakeReservation.mock.funcMakeReservation != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by Set")
	}

	if mmMakeReservation.defaultExpectation == nil {
		mmMakeReservation.defaultExpectation = &ReservationStorageMockMakeReservationExpectation{}
	}

	if mmMakeReservation.defaultExpectation.params != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by Expect")
	}

	if mmMakeReservation.defaultExpectation.paramPtrs == nil {
		mmMakeReservation.defaultExpectation.paramPtrs = &ReservationStorageMockMakeReservationParamPtrs{}
	}
	mmMakeReservation.defaultExpectation.paramPtrs.reservation = &reservation
	mmMakeReservation.defaultExpectation.expectationOrigins.originReservation = minimock.CallerInfo(1)

	return mmMakeReservation
}

// Inspect accepts an inspector function that has same arguments as the reservationStorage.MakeReservation
func (mmMakeReservation *mReservationStorageMockMakeReservation) Inspect(f func(reservation Reservation)) *mReservationStorageMockMakeReservation {
	if mmMakeReservation.mock.inspectFuncMakeReservation != nil {
		mmMakeReservation.mock.t.Fatalf("Inspect function is already set for ReservationStorageMock.MakeReservation")
	}

	mmMakeReservation.mock.inspectFuncMakeReservation = f

	return mmMakeReservation
}

// Return sets up results that will be returned by reservationStorage.MakeReservation
func (mmMakeReservation *mReservationStorageMockMakeReservation) Return(err error) *ReservationStorageMock {
	if mmMakeReservation.mock.funcMakeReservation != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by Set")
	}

	if mmMakeReservation.defaultExpectation == nil {
		mmMakeReservation.defaultExpectation = &ReservationStorageMockMakeReservationExpectation{mock: mmMakeReservation.mock}
	}
	mmMakeReservation.defaultExpectation.results = &ReservationStorageMockMakeReservationResults{err}
	mmMakeReservation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMakeReservation.mock
}

// Set uses given function f to mock the reservationStorage.MakeReservation method
func (mmMakeReservation *mReservationStorageMockMakeReservation) Set(f func(reservation Reservation) (err error)) *ReservationStorageMock {
	if mmMakeReservation.defaultExpectation != nil {
		mmMakeReservation.mock.t.Fatalf("Default expectation is already set for the reservationStorage.MakeReservation method")
	}

	if len(mmMakeReservation.expectations) > 0 {
		mmMakeReservation.mock.t.Fatalf("Some expectations are already set for the reservationStorage.MakeReservation method")
	}

	mmMakeReservation.mock.funcMakeReservation = f
	mmMakeReservation.mock.funcMakeReservationOrigin = minimock.CallerInfo(1)
	return mmMakeReservation.mock
}

// When sets expectation for the reservationStorage.MakeReservation which will trigger the result defined by the following
// Then helper
func (mmMakeReservation *mReservationStorageMockMakeReservation) When(reservation Reservation) *ReservationStorageMockMakeReservationExpectation {
	if mmMakeReservation.mock.funcMakeReservation != nil {
		mmMakeReservation.mock.t.Fatalf("ReservationStorageMock.MakeReservation mock is already set by Set")
	}

	expectation := &ReservationStorageMockMakeReservationExpectation{
		mock:               mmMakeReservation.mock,
		params:             &ReservationStorageMockMakeReservationParams{reservation},
		expectationOrigins: ReservationStorageMockMakeReservationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMakeReservation.expectations = append(mmMakeReservation.expectations, expectation)
	return expectation
}

// Then sets up reservationStorage.MakeReservation return parameters for the expectation previously defined by the When method
func (e *ReservationStorageMockMakeReservationExpectation) Then(err error) *ReservationStorageMock {
	e.results = &ReservationStorageMockMakeReservationResults{err}
	return e.mock
}

// Times sets number of times reservationStorage.MakeReservation should be invoked
func (mmMakeReservation *mReservationStorageMockMakeReservation) Times(n uint64) *mReservationStorageMockMakeReservation {
	if n == 0 {
		mmMakeReservation.mock.t.Fatalf("Times of ReservationStorageMock.MakeReservation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMakeReservation.expectedInvocations, n)
	mmMakeReservation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMakeReservation
}

func (mmMakeReservation *mReservationStorageMockMakeReservation) invocationsDone() bool {
	if len(mmMakeReservation.expectations) == 0 && mmMakeReservation.defaultExpectation == nil && mmMakeReservation.mock.funcMakeReservation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMakeReservation.mock.afterMakeReservationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMakeReservation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MakeReservation implements reservationStorage
func (mmMakeReservation *ReservationStorageMock) MakeReservation(reservation Reservation) (err error) {
	mm_atomic.AddUint64(&mmMakeReservation.beforeMakeReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeReservation.afterMakeReservationCounter, 1)

	mmMakeReservation.t.Helper()

	if mmMakeReservation.inspectFuncMakeReservation != nil {
		mmMakeReservation.inspectFuncMakeReservation(reservation)
	}

	mm_params := ReservationStorageMockMakeReservationParams{reservation}

	// Record call args
	mmMakeReservation.MakeReservationMock.mutex.Lock()
	mmMakeReservation.MakeReservationMock.callArgs = append(mmMakeReservation.MakeReservationMock.callArgs, &mm_params)
	mmMakeReservation.MakeReservationMock.mutex.Unlock()

	for _, e := range mmMakeReservation.MakeReservationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMakeReservation.MakeReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeReservation.MakeReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmMakeReservation.MakeReservationMock.defaultExpectation.params
		mm_want_ptrs := mmMakeReservation.MakeReservationMock.defaultExpectation.paramPtrs

		mm_got := ReservationStorageMockMakeReservationParams{reservation}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.reservation != nil && !minimock.Equal(*mm_want_ptrs.reservation, mm_got.reservation) {
				mmMakeReservation.t.Errorf("ReservationStorageMock.MakeReservation got unexpected parameter reservation, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMakeReservation.MakeReservationMock.defaultExpectation.expectationOrigins.originReservation, *mm_want_ptrs.reservation, mm_got.reservation, minimock.Diff(*mm_want_ptrs.reservation, mm_got.reservation))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMakeReservation.t.Errorf("ReservationStorageMock.MakeReservation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMakeReservation.MakeReservationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMakeReservation.MakeReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeReservation.t.Fatal("No results are set for the ReservationStorageMock.MakeReservation")
		}
		return (*mm_results).err
	}
	if mmMakeReservation.funcMakeReservation != nil {
		return mmMakeReservation.funcMakeReservation(reservation)
	}
	mmMakeReservation.t.Fatalf("Unexpected call to ReservationStorageMock.MakeReservation. %v", reservation)
	return
}

// MakeReservationAfterCounter returns a count of finished ReservationStorageMock.MakeReservation invocations
func (mmMakeReservation *ReservationStorageMock) MakeReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeReservation.afterMakeReservationCounter)
}

// MakeReservationBeforeCounter returns a count of ReservationStorageMock.MakeReservation invocations
func (mmMakeReservation *ReservationStorageMock) MakeReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeReservation.beforeMakeReservationCounter)
}

// Calls returns a list of arguments used in each call to ReservationStorageMock.MakeReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeReservation *mReservationStorageMockMakeReservation) Calls() []*ReservationStorageMockMakeReservationParams {
	mmMakeReservation.mutex.RLock()

	argCopy := make([]*ReservationStorageMockMakeReservationParams, len(mmMakeReservation.callArgs))
	copy(argCopy, mmMakeReservation.callArgs)

	mmMakeReservation.mutex.RUnlock()

	return argCopy
}

// MinimockMakeReservationDone returns true if the count of the MakeReservation invocations corresponds
// the number of defined expectations
func (m *ReservationStorageMock) MinimockMakeReservationDone() bool {
	if m.MakeReservationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MakeReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MakeReservationMock.invocationsDone()
}

// MinimockMakeReservationInspect logs each unmet expectation
func (m *ReservationStorageMock) MinimockMakeReservationInspect() {
	for _, e := range m.MakeReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReservationStorageMock.MakeReservation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMakeReservationCounter := mm_atomic.LoadUint64(&m.afterMakeReservationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MakeReservationMock.defaultExpectation != nil && afterMakeReservationCounter < 1 {
		if m.MakeReservationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReservationStorageMock.MakeReservation at\n%s", m.MakeReservationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReservationStorageMock.MakeReservation at\n%s with params: %#v", m.MakeReservationMock.defaultExpectation.expectationOrigins.origin, *m.MakeReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeReservation != nil && afterMakeReservationCounter < 1 {
		m.t.Errorf("Expected call to ReservationStorageMock.MakeReservation at\n%s", m.funcMakeReservationOrigin)
	}

	if !m.MakeReservationMock.invocationsDone() && afterMakeReservationCounter > 0 {
		m.t.Errorf("Expected %d calls to ReservationStorageMock.MakeReservation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MakeReservationMock.expectedInvocations), m.MakeReservationMock.expectedInvocationsOrigin, afterMakeReservationCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReservationStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelReservationInspect()

			m.MinimockGetReservationInspect()

			m.MinimockGetReservationsInspect()

			m.MinimockMakeReservationInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReservationStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReservationStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelReservationDone() &&
		m.MinimockGetReservationDone() &&
		m.MinimockGetReservationsDone() &&
		m.MinimockMakeReservationDone()
}
